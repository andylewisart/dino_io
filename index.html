<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino.io - Endless Evolution</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Ubuntu', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Action Bar (Top Center Upgrades) */
        #action-bar {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            pointer-events: auto;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
        }

        .action-btn {
            width: 48px;
            height: 48px;
            background-color: #222;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            background-image: url('spritesheets/icons.png');
            background-size: 733.33% 400%; 
            transition: transform 0.1s, border-color 0.2s, filter 0.2s;
        }

        .action-btn:hover {
            transform: scale(1.1);
            border-color: #fff;
            z-index: 10;
        }
        
        .action-btn.disabled {
            filter: grayscale(1.0) brightness(0.4);
            cursor: default;
        }
        
        .action-btn.active {
            border-color: #0f0;
            box-shadow: 0 0 8px #0f0;
            animation: pulse 1s infinite;
            filter: brightness(1.2);
        }

        .stat-lvl {
            position: absolute;
            bottom: -6px;
            right: -6px;
            background: #222;
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 3px;
            border-radius: 3px;
            border: 1px solid #555;
            min-width: 12px;
            text-align: center;
        }
        
        .stat-key-hint {
            position: absolute;
            top: -6px;
            left: -6px;
            background: #444;
            color: #ddd;
            font-size: 9px;
            padding: 1px 3px;
            border-radius: 3px;
            border: 1px solid #666;
        }
        
        /* Tooltip on hover */
        .action-btn::after {
            content: attr(data-title);
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
        }
        .action-btn:hover::after {
            opacity: 1;
        }

        @keyframes pulse {
            0% { transform: scale(1.0); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1.0); }
        }

        /* Class Selection Menu (Centered) */
        #class-upgrade-menu {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            width: 100%;
            max-width: 1000px;
            z-index: 100;
        }

        .class-card {
            width: 160px;
            min-height: 220px;
            background: linear-gradient(180deg, rgba(40,40,50,0.95) 0%, rgba(20,20,30,0.98) 100%);
            border: 2px solid #4facfe;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            transition: transform 0.2s;
            text-align: center;
            position: relative;
        }
        
        .class-card-icon {
            width: 64px;
            height: 64px;
            background-color: #111;
            border: 2px solid #fff;
            border-radius: 8px;
            margin-bottom: 12px;
            background-image: url('icons.png');
            background-size: 733.33% 400%;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        .class-card.mutation {
            background: linear-gradient(180deg, rgba(60,20,20,0.95) 0%, rgba(30,10,10,0.98) 100%);
            border-color: #ff0844;
        }

        .class-card:hover {
            transform: translateY(-8px) scale(1.05);
            filter: brightness(1.2);
            z-index: 10;
            border-color: white;
        }

        .class-card-title {
            color: white;
            font-weight: 800;
            font-size: 15px;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 8px;
        }
        
        .class-card-desc {
            color: #ccc;
            font-size: 11px;
            line-height: 1.4;
            font-style: italic;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            pointer-events: none;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Colors for stats */
        .c-1 { background-color: #e59e9e; }
        .c-2 { background-color: #ea9ee5; }
        .c-3 { background-color: #9e9ee5; }
        .c-4 { background-color: #9ee5e3; }
        .c-5 { background-color: #9ee59e; }
        .c-6 { background-color: #e2e59e; }
        .c-7 { background-color: #e5c59e; }
        .c-8 { background-color: #9ee5ce; }

        /* Score & Level */
        #hud-top {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #score-text {
            color: white;
            font-size: 24px;
            font-weight: 800;
            text-shadow: 2px 2px 0 #000;
        }

        #class-text {
            color: #eee;
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 1px 1px 0 #000;
        }

        #run-text {
            color: #cfcfcf;
            font-size: 12px;
            margin-top: 4px;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.95;
        }

        #objective-text {
            color: #ffd37a;
            font-size: 12px;
            margin-top: 2px;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.95;
        }

        #water-warning {
            display: none;
            color: #ff6b6b;
            font-size: 13px;
            margin-top: 4px;
            text-shadow: 2px 2px 0 #000;
            font-weight: 900;
            letter-spacing: 0.5px;
        }

        #xp-bar-container {
            width: 400px;
            height: 15px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #xp-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffc107, #ff9800);
            transition: width 0.2s;
        }

        /* Notifications */
        #notification-area {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }
        
        .notification {
            color: white;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 5px black;
            animation: fadeOut 3s forwards;
            margin-bottom: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(-20px); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        #crystal-hud {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }

        .crystal-slot {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
        }
        
        .crystal-slot.filled {
            border-color: white;
            transform: scale(1.1);
            background: rgba(0,0,0,0.7);
        }

        .crystal-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px; /* Rough gem shape base */
            transform: rotate(45deg);
            opacity: 0.3;
            transition: opacity 0.5s, box-shadow 0.5s;
        }

        .crystal-slot.filled .crystal-icon {
            opacity: 1;
            box-shadow: 0 0 15px currentColor;
        }

        /* Adjust Mobile Controls to not overlap if needed */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
        }
        
        .joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
            border: 2px solid rgba(255,255,255,0.2);
        }

        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        
        .stick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 35px;
            left: 35px;
            pointer-events: none;
        }

        /* Boss Bar */
        #boss-bar-container {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 20px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #555;
            border-radius: 4px;
            display: none; 
            z-index: 10;
        }
        #boss-bar-fill {
            height: 100%;
            background: #f00;
            width: 100%;
            transition: width 0.1s;
            box-shadow: 0 0 10px #f00;
        }
        #boss-name {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            color: #f55;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        
        /* Game Over Screen */
        #game-over-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 50;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #555;
        }
        
        #ai-death-message {
            font-size: 18px;
            color: #ccc;
            font-style: italic;
            margin-top: 10px;
            max-width: 600px;
        }

        /* Reward / Run Complete Overlays */
        #reward-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.72);
            z-index: 80;
            pointer-events: auto;
        }

        #reward-panel {
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 18px 18px 22px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 0 15px 35px rgba(0,0,0,0.7);
            max-width: 1100px;
            width: calc(100% - 40px);
        }

        #reward-title {
            color: white;
            font-weight: 900;
            font-size: 22px;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 14px;
        }

        #reward-subtitle {
            color: #ddd;
            font-size: 13px;
            margin-top: -8px;
            margin-bottom: 18px;
            text-shadow: 1px 1px 0 #000;
        }

        #reward-menu {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        #run-complete-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 90;
            background: rgba(0,0,0,0.85);
            padding: 22px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.15);
            pointer-events: auto;
            max-width: 620px;
            width: calc(100% - 40px);
        }

        #run-complete-ui h1 {
            color: #fff;
            font-size: 42px;
            margin: 0;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        #run-complete-text {
            color: #ddd;
            font-size: 16px;
            margin-top: 10px;
            text-shadow: 1px 1px 0 #000;
        }

        .ui-btn {
            margin-top: 16px;
            background: rgba(50, 200, 120, 0.75);
            color: white;
            border: 1px solid rgba(255,255,255,0.25);
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 8px;
            pointer-events: auto;
            font-weight: 800;
            letter-spacing: 0.3px;
        }

        .ui-btn:hover {
            background: rgba(50, 220, 140, 0.95);
        }

        #reset-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(200, 50, 50, 0.6);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: auto;
            font-weight: bold;
            z-index: 100;
        }
        #reset-btn:hover {
            background: rgba(255, 50, 50, 0.9);
        }

        #boss-slain-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Flex when active */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.6);
            z-index: 95;
            pointer-events: none;
            animation: fadeIn 0.5s forwards;
        }

        #boss-slain-text {
            font-size: 80px;
            font-weight: 900;
            color: #ff3333;
            text-transform: uppercase;
            text-shadow: 0 0 20px #ff0000, 4px 4px 0 #000;
            letter-spacing: 4px;
            transform: scale(0);
            animation: slam 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.2s;
        }

        #boss-slain-sub {
            font-size: 24px;
            color: #fff;
            margin-top: 20px;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            animation: slideUp 0.8s ease-out forwards 1.0s;
        }

        @keyframes slam {
            0% { transform: scale(3); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes slideUp {
            0% { transform: translateY(20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div id="reset-btn" onclick="resetGame()">RESTART RUN</div>
    <div id="respec-btn" onclick="refundStats()" style="position: absolute; top: 10px; right: 110px; background: rgba(50, 150, 200, 0.6); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 12px; cursor: pointer; font-size: 12px; border-radius: 4px; pointer-events: auto; font-weight: bold;">RESPEC</div>
    <div id="hud-top">
        <div id="score-text">Score: 0</div>
        <div id="class-text">Lvl 1 Baby Dino</div>
        <div id="run-text">Level 1/2 â€¢ Lives 5/5 â€¢ Jewels 0/5</div>
        <div id="objective-text"></div>
        <div id="water-warning"></div>
        <div id="xp-bar-container">
            <div id="xp-bar-fill"></div>
        </div>
    </div>
    
    <div id="boss-bar-container">
        <div id="boss-name">ALPHA GUARDIAN</div>
        <div id="boss-bar-fill"></div>
    </div>

    <!-- Class Selector -->
    <div id="class-upgrade-menu"></div>

    <div id="crystal-hud"></div>

    <div id="action-bar">
        <!-- Stat buttons -->
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas" width="200" height="200"></canvas>
    </div>

    <div id="notification-area"></div>
    
    <div id="game-over-ui">
        <h1 style="color:white; font-size:40px; margin:0; text-shadow:0 0 10px red;">YOU DIED</h1>
        <div id="respawn-text" style="color:white; font-size:24px;">Respawning...</div>
        <div id="ai-death-message">âœ¨ Analyzing defeat...</div>
    </div>

    <div id="boss-slain-ui">
        <div id="boss-slain-text">PREY SLAUGHTERED</div>
        <div id="boss-slain-sub">Evolution Imminent...</div>
    </div>

    <div id="reward-overlay">
        <div id="reward-panel">
            <div id="reward-title">Choose Your Next Species</div>
            <div id="reward-subtitle">Boss defeated. Your evolution awaits.</div>
            <div id="reward-menu"></div>
        </div>
    </div>

    <div id="run-complete-ui">
        <h1>RUN COMPLETE</h1>
        <div id="run-complete-text">You cleared all available levels.</div>
        <button class="ui-btn" onclick="resetGame()">RESTART RUN</button>
    </div>

    <div id="mobile-controls">
        <div id="stick-left" class="joystick-zone"><div class="stick-knob"></div></div>
        <div id="stick-right" class="joystick-zone"><div class="stick-knob"></div></div>
    </div>
</div>

<script>
/**
 * DINO.IO - ENDLESS EVOLUTION
 */

// --- GLOBAL VARIABLES & STATE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// Camera
const camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };

// Inputs
const keys = {};
const mouse = { x: 0, y: 0, down: false };
const joystickLeft = { x: 0, y: 0, active: false };
const joystickRight = { x: 0, y: 0, active: false };

// Game Entities & State
let player;
let entities = [];
let powerUps = [];
let particles = [];
let damageNumbers = [];
let explosions = []; 
let boss = null;
let bossArena = null;
let lastTime = 0;
let respawnTimer = 3;
let gameMode = 'play'; // 'play' | 'reward' | 'complete'
let runResetTimer = 0;

const RUN_CONFIG = {
    totalStages: 2,
    maxLives: 5,
};

let runState = {
    stageIndex: 0,
    lives: RUN_CONFIG.maxLives,
    score: 0,
    selectedSpecies: 'Baby Dino',
    spawnX: 0,
    spawnY: 0,
};

let stageState = null;
let currentStageDef = null;

// --- Constants & Config ---
const apiKey = ""; // Provided by environment
const CONFIG = {
    mapWidth: 6000,
    mapHeight: 6000,
    gridSize: 400,
    baseFPS: 60,
    nestRadius: 800,
};

// --- AUDIO SYSTEM ---
const AudioSys = {
    ctx: null,
    lastPlayed: {},
    deathAudio: new Audio('YOUDIED.mp3'),
    bgMusic: new Audio('Jurassic_Journey.mp3'),
    bossMusic: new Audio('BossBattle.mp3'),
    victoryMusic: new Audio('DefeatedBoss.mp3'),
    playlist: ['Jurassic_Journey.mp3', 'Dino_Plains_Drifter.mp3'],
    trackIndex: 0,

    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.deathAudio.load(); // Preload
            this.bossMusic.load(); // Preload
            this.victoryMusic.load(); // Preload
            
            this.bgMusic.loop = false;
            this.bgMusic.volume = 0.3;
            
            // Playlist logic
            this.bgMusic.addEventListener('ended', () => {
                this.trackIndex = (this.trackIndex + 1) % this.playlist.length;
                this.bgMusic.src = this.playlist[this.trackIndex];
                this.bgMusic.play().catch(e => console.log("Next track play failed", e));
            });
            
            // Victory music to Normal queue
            this.victoryMusic.addEventListener('ended', () => {
                 this.resumeNormalMusic();
            });
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        if (this.bgMusic.paused) {
            this.bgMusic.play().catch(e => console.log("BG Music waiting for interaction"));
        }
    },
    playDeathSound: function() {
        this.bgMusic.pause();
        this.bossMusic.pause();
        this.victoryMusic.pause();
        
        // Create fresh instance to avoid state/seek issues
        const sfx = new Audio('YOUDIED.mp3');
        sfx.volume = 1.0;
        sfx.play().catch(e => {
            console.error("Death audio failed:", e);
            // Fallback: Sad Trombone
            this.playTone(150, 'sawtooth', 0.5, 0.2);
            setTimeout(() => this.playTone(100, 'sawtooth', 0.8, 0.2), 400);
        });
    },
    resumeMusic: function() {
        if (this.bgMusic.paused && this.bossMusic.paused && this.victoryMusic.paused) {
            this.bgMusic.play().catch(e => console.log("Resume music failed", e));
        }
    },
    playBossMusic: function() {
        this.bgMusic.pause();
        this.victoryMusic.pause();
        this.bossMusic.loop = true;
        this.bossMusic.volume = 0.4;
        this.bossMusic.currentTime = 0;
        this.bossMusic.play().catch(e => console.log("Boss music failed", e));
    },
    playVictoryMusic: function() {
        this.bgMusic.pause();
        this.bossMusic.pause();
        this.victoryMusic.loop = false;
        this.victoryMusic.volume = 0.5;
        this.victoryMusic.currentTime = 0;
        this.victoryMusic.play().catch(e => console.log("Victory music failed", e));
    },
    resumeNormalMusic: function() {
        this.bossMusic.pause();
        this.victoryMusic.pause();
        this.bossMusic.currentTime = 0;
        this.victoryMusic.currentTime = 0;
        if (this.bgMusic.paused) this.bgMusic.play().catch(e => console.log("Normal music failed", e));
    },
    playTone: function(freq, type, duration, vol=0.1, id=null) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const key = id || type;
        if (this.lastPlayed[key] && now - this.lastPlayed[key] < (id === 'hit' ? 0.08 : 0.05)) return;
        this.lastPlayed[key] = now;

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot: function(type='standard') { 
        if (type === 'laser') this.playTone(800, 'sine', 0.1, 0.05, 'shoot_laser'); 
        else if (type === 'flame') this.playTone(100, 'sawtooth', 0.2, 0.03, 'shoot_flame'); 
        else if (type === 'bomb') this.playTone(150, 'square', 0.2, 0.1, 'shoot_bomb');
        else this.playTone(rand(300, 600), 'triangle', 0.1, 0.05, 'shoot_std');
    },
    explode: function() { 
        this.playTone(100, 'sawtooth', 0.3, 0.1, 'explode'); 
        this.playTone(50, 'square', 0.4, 0.1, 'explode2');
    },
    hit: function() {
        this.playTone(800, 'sine', 0.05, 0.05, 'hit');
    },
    die: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    },
    crunch: function() {
        this.playTone(60, 'sawtooth', 0.1, 0.1, 'crunch');
        this.playTone(100, 'square', 0.05, 0.1, 'crunch2');
    },
    levelUp: function() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        [440, 554, 659].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.value = f;
            gain.gain.setValueAtTime(0.1, now + i*0.1);
            gain.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(now + i*0.1);
            osc.stop(now + i*0.1 + 0.3);
        });
    }
};

// --- GEMINI AI SYSTEM ---
let pendingBossData = null;

async function callGemini(prompt) {
    if (!apiKey) return null;
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text;
    } catch (e) {
        console.error("Gemini Error:", e);
        return null;
    }
}

async function prepareNextBoss(level) {
    if (pendingBossData) return; 
    
    const prompt = `Generate a JSON object for a dinosaur boss in a shooter game. Level ${level}. 
    Fields: 
    - name (string, sci-fi/scary title)
    - color (hex string)
    - trait (one of: 'armored', 'evasive', 'ablative', 'spiked')
    - weaponType (one of: 'bomb', 'laser', 'flame', 'missile')
    - gunCount (integer 3-8)
    Do not use markdown. Just JSON.`;
    
    const text = await callGemini(prompt);
    if (text) {
        try {
            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            pendingBossData = JSON.parse(cleanText);
            console.log("Next Boss Ready:", pendingBossData);
        } catch (e) { console.error("Boss Parse Error", e); }
    }
}

async function getDeathMessage(stats) {
    const prompt = `Player died in Dino.io. 
    Level: ${stats.level}. 
    Score: ${stats.score}. 
    Killer: ${stats.killer}. 
    Write a short, funny, 1-sentence snarky comment or eulogy about their failure.`;
    
    const text = await callGemini(prompt);
    if (text) {
        const el = document.getElementById('ai-death-message');
        if (el) el.innerText = "âœ¨ " + text.trim();
    }
}

// --- SPATIAL GRID (PERFORMANCE) ---
class SpatialHash {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(CONFIG.mapWidth / cellSize);
        this.rows = Math.ceil(CONFIG.mapHeight / cellSize);
        this.buckets = new Array(this.cols * this.rows).fill(null).map(() => []);
    }
    clear() {
        for(let i=0; i<this.buckets.length; i++) {
            this.buckets[i].length = 0; 
        }
    }
    insert(entity) {
        const cx = Math.floor(entity.x / this.cellSize);
        const cy = Math.floor(entity.y / this.cellSize);
        if (cx >= 0 && cx < this.cols && cy >= 0 && cy < this.rows) {
            this.buckets[cx + cy * this.cols].push(entity);
        }
    }
    query(entity) {
        const cx = Math.floor(entity.x / this.cellSize);
        const cy = Math.floor(entity.y / this.cellSize);
        let results = [];
        for(let x = cx-1; x<=cx+1; x++) {
            for(let y = cy-1; y<=cy+1; y++) {
                if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                    const bucket = this.buckets[x + y * this.cols];
                    for(let i=0; i<bucket.length; i++) results.push(bucket[i]);
                }
            }
        }
        return results;
    }
}
const spatialGrid = new SpatialHash(200);

const STAT_TYPES = [
    { id: 0, name: "Health Regen", color: "#e59e9e" },
    { id: 1, name: "Max Health", color: "#ea9ee5" },
    { id: 2, name: "Body Damage", color: "#9e9ee5" },
    { id: 3, name: "Bullet Speed", color: "#9ee5e3" },
    { id: 4, name: "Bullet Pen", color: "#9ee59e" },
    { id: 5, name: "Bullet Dmg", color: "#e2e59e" },
    { id: 6, name: "Reload", color: "#e5c59e" },
    { id: 7, name: "Move Speed", color: "#9ee5ce" },
    { id: 8, name: "Magnet", color: "#a0a0ff" },
];

const STAT_ICONS = [
    {r:0, c:0}, {r:0, c:1}, {r:0, c:2}, {r:0, c:3},
    {r:1, c:0}, {r:1, c:1}, {r:1, c:2}, {r:1, c:3},
    {r:2, c:0}
];

const CLASS_DEFS = {
    'Baby Dino': { tier: 0, scale: 0.6, guns: [{a:0, x:0, y:0, w:0.4, h:1.2, type:'standard'}] },
    'Raptor':      { tier: 1, label: "Twin", scale: 0.85, guns: [{a:0, x:0, y:-0.4, w:0.4, h:1.3, type:'standard'}, {a:0, x:0, y:0.4, w:0.4, h:1.3, type:'standard'}] }, 
    'Dilophosaur': { tier: 1, label: "Flamer", scale: 0.9, guns: [{a:0, x:0, y:0, w:0.5, h:1.0, type:'flame'}] }, 
    'Stegosaurus': { tier: 1, label: "Launcher", scale: 1.0, guns: [{a:0, x:0, y:0, w:0.6, h:1.2, type:'bomb'}] }, 
    'Pterodactyl': { tier: 1, label: "Railgun", scale: 0.9, fov: 1.3, guns: [{a:0, x:0.2, y:0, w:0.45, h:1.8, type:'laser'}] }, 
    'Triceratops': { tier: 2, label: "Triple Shot", scale: 1.2, guns: [{a:0, x:0, y:0, w:0.4, h:1.3, type:'standard'}, {a:-0.3, x:0, y:0, w:0.4, h:1.2, type:'standard'}, {a:0.3, x:0, y:0, w:0.4, h:1.2, type:'standard'}] },
    'Giganotosaurus':{ tier: 2, label: "Inferno", scale: 1.3, guns: [{a:0, x:0, y:-0.3, w:0.3, h:1.1, type:'flame'}, {a:0, x:0, y:0.3, w:0.3, h:1.1, type:'flame'}] },
    'Spinosaurus':   { tier: 2, label: "Cluster Bomb", scale: 1.3, guns: [{a:0, x:0.2, y:-0.4, w:0.8, h:1.4, type:'bomb'}, {a:0, x:0.2, y:0.4, w:0.8, h:1.4, type:'bomb'}] },
    'Archaeopteryx': { tier: 2, label: "Twin Rail", scale: 1.1, fov: 1.5, guns: [{a:0, x:0.2, y:-0.3, w:0.45, h:1.8, type:'laser'}, {a:0, x:0.2, y:0.3, w:0.45, h:1.8, type:'laser'}] },

    // Tier 3 (Lvl 45)
    'Titanosaur':    { tier: 3, label: "Octo-Cannon", scale: 1.8, guns: [0,1,2,3,4,5,6,7].map(i => ({a:i*(Math.PI/4), x:0, y:0, w:0.4, h:1.2, type:'standard'})) },
    'Indominus':     { tier: 3, label: "Hydra Flame", scale: 1.6, guns: [{a:0, x:0, y:0, w:0.4, h:1.2, type:'flame'}, {a:-0.2, x:0, y:0, w:0.4, h:1.2, type:'flame'}, {a:0.2, x:0, y:0, w:0.4, h:1.2, type:'flame'}] },
    'T-Rex':         { tier: 3, label: "Czar Nuke", scale: 1.7, guns: [{a:0, x:0.3, y:0, w:1.5, h:2.0, type:'bomb'}] }, 
    'Velociraptor':  { tier: 3, label: "Quad Beam", scale: 1.2, fov: 1.7, guns: [{a:0, x:0, y:-0.6, w:0.4, h:1.8, type:'laser'}, {a:0, x:0, y:-0.2, w:0.4, h:1.8, type:'laser'}, {a:0, x:0, y:0.2, w:0.4, h:1.8, type:'laser'}, {a:0, x:0, y:0.6, w:0.4, h:1.8, type:'laser'}] }
};

const UPGRADE_TREE = {
    15: ['Raptor', 'Dilophosaur', 'Stegosaurus', 'Pterodactyl'],
    30: {
        'Raptor': ['Triceratops'],
        'Dilophosaur': ['Giganotosaurus'],
        'Stegosaurus': ['Spinosaurus'],
        'Pterodactyl': ['Archaeopteryx']
    },
    45: {
        'Triceratops': ['Titanosaur'],
        'Giganotosaurus': ['Indominus'],
        'Spinosaurus': ['T-Rex'],
        'Archaeopteryx': ['Velociraptor']
    }
};

const BOSS_TEMPLATES = [
    { name: "Alpha Guardian", color: "#aa00cc", scale: 1.0, hpMult: 1.0, trait: "ablative", guns: [{a:0, x:0, y:0, w:0.8, h:1.5, type:'bomb'}, {a:Math.PI/2, x:0, y:0, w:0.8, h:1.5, type:'bomb'}, {a:Math.PI, x:0, y:0, w:0.8, h:1.5, type:'bomb'}, {a:-Math.PI/2, x:0, y:0, w:0.8, h:1.5, type:'bomb'}] },
    { name: "Omega Destroyer", color: "#cc0000", scale: 1.3, hpMult: 1.5, trait: "armored", guns: [{a:0, x:0.4, y:0, w:1.4, h:2.0, type:'bomb'}, {a:0.3, x:-0.2, y:0.6, w:0.5, h:1.2, type:'missile'}, {a:-0.3, x:-0.2, y:-0.6, w:0.5, h:1.2, type:'missile'}] },
    { name: "Solar Titan", color: "#ff8800", scale: 1.1, hpMult: 1.2, trait: "spiked", guns: [0,1,2,3,4,5,6,7].map(i => ({a:i*(Math.PI/4), x:0, y:0, w:0.6, h:1.4, type:'flame'})) },
    { name: "Void Prism", color: "#00ccff", scale: 0.9, hpMult: 0.8, trait: "evasive", guns: [0,1,2,3,4,5].map(i => ({a:i*(Math.PI/3), x:0, y:0, w:0.5, h:2.5, type:'laser'})) },
    { name: "Brood Mother", color: "#00ff00", scale: 1.2, hpMult: 1.1, trait: "ablative", guns: [{a:0.5, x:0, y:0.5, w:0.6, h:1.5, type:'missile'}, {a:-0.5, x:0, y:-0.5, w:0.6, h:1.5, type:'missile'}, {a:2.5, x:-0.5, y:0.5, w:0.6, h:1.5, type:'missile'}, {a:-2.5, x:-0.5, y:-0.5, w:0.6, h:1.5, type:'missile'}] }
];

const MUTATIONS = [
    { name: "Extra Cannon", desc: "Add a Standard Cannon.", action: (p) => p.addBonusGun('standard') },
    { name: "Graft Laser", desc: "Add a Laser Turret.", action: (p) => p.addBonusGun('laser') },
    { name: "Graft Flamer", desc: "Add a Flamethrower.", action: (p) => p.addBonusGun('flame') },
    { name: "Graft Launcher", desc: "Add a Bomb Launcher.", action: (p) => p.addBonusGun('bomb') },
    { name: "Tesla Aura", desc: "Zap nearby foes.", action: (p) => { p.hasTesla = true; p.teslaPower = (p.teslaPower || 0) + 1; } },
    { name: "Orbital Saw", desc: "Protective blade.", action: (p) => { p.orbitals.push({angle: (Math.PI*2/ (p.orbitals.length+1)) * p.orbitals.length, r: 15, dist: p.r * 2}); } },
    { name: "Gigantism", desc: "+30% Size/HP.", action: (p) => { p.scaleMult *= 1.3; p.recalcStats(); } },
    { name: "Titan Skin", desc: "+25% Armor.", action: (p) => { p.stats[1] += 5; p.stats[2] += 5; p.recalcStats(); } }
];

// --- Run / Stage Definitions ---
const JEWEL_TYPES = [
    { id: 'ruby', name: 'Ruby', color: '#ff3355' },
    { id: 'sapphire', name: 'Sapphire', color: '#2f7bff' },
    { id: 'emerald', name: 'Emerald', color: '#34ff89' },
    { id: 'amethyst', name: 'Amethyst', color: '#b44cff' },
    { id: 'topaz', name: 'Topaz', color: '#ffd34a' },
];

const STAGE_DEFS = [
    {
        name: 'Level 1',
        terrainSrc: 'terrain.jpg',
        terrain: {
            grass: { count: 50, minR: 1, maxR: 3 },
            waterSmall: { count: 16, minR: 1, maxR: 2 },
            waterBig: { count: 1, minR: 4, maxR: 6 },
            lava: { count: 6, minR: 1, maxR: 1 },
        },
        spawn: {
            initialShapes: 520,
            initialPowerUps: 18,
            initialEnemies: 6,
            desiredShapes: 620,
            maxEnemiesBase: 12,
            maxEnemiesPerLevel: 0.45,
            startInvulnerable: 2.5,
        },
        enemy: {
            levelOffset: 0,
            minDelta: -1,
            maxDelta: 0,
            statsDiv: 4,
            rangedChance: 0.10,
            traitChance: 0.20,
            healthMult: 0.85,
            damageMult: 0.80,
            moveSpeedMult: 0.92,
        },
        jewelTotal: 5,
        waterJewelCount: 0,
        minimapReveal: { jewel: 800, gate: 900 },
        difficultyOffset: 0,
        mosasaur: {
            entryChance: 0.35,
            lingerTime: 12.0,
            lingerChancePerSecond: 0.08,
            warningTime: 4.5,
            attackTime: 12.0,
            rollInterval: 0.8,
            attackChancePerSecond: 0.35,
            attackChanceRamp: 0.08,
            attackMaxChance: 0.85,
            cooldown: 9.0,
            speed: 950,
            biteDamageMult: 1.0
        },
        nextSpeciesOptions: ['Triceratops', 'Giganotosaurus', 'Spinosaurus', 'Archaeopteryx'],
    },
    {
        name: 'Level 2',
        terrainSrc: 'terrainFrozen.jpg',
        terrain: {
            grass: { count: 40, minR: 1, maxR: 3 },
            waterSmall: { count: 10, minR: 1, maxR: 2 },
            waterBig: { count: 2, minR: 5, maxR: 8 },
            lava: { count: 8, minR: 1, maxR: 1 },
        },
        spawn: {
            initialShapes: 560,
            initialPowerUps: 16,
            initialEnemies: 8,
            desiredShapes: 650,
            maxEnemiesBase: 16,
            maxEnemiesPerLevel: 0.55,
            startInvulnerable: 2.0,
        },
        enemy: {
            levelOffset: 2,
            minDelta: -1,
            maxDelta: 1,
            statsDiv: 3,
            rangedChance: 0.18,
            traitChance: 0.35,
            healthMult: 0.95,
            damageMult: 0.95,
            moveSpeedMult: 0.98,
        },
        jewelTotal: 5,
        waterJewelCount: 1,
        minimapReveal: { jewel: 850, gate: 950 },
        difficultyOffset: 4,
        mosasaur: null,
        nextSpeciesOptions: ['Titanosaur', 'Indominus', 'T-Rex', 'Velociraptor'],
    },
];

// --- Utility Functions ---
const rand = (min, max) => Math.random() * (max - min) + min;
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const checkCollide = (c1, c2) => {
    const dx = c1.x - c2.x;
    const dy = c1.y - c2.y;
    const dist = c1.r + c2.r;
    return (dx*dx + dy*dy) < dist*dist;
};
const adjustColor = (color, amount) => {
    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
};

// --- Classes ---

class ExplosionEffect {
    constructor(x, y, r) {
        this.x = x;
        this.y = y;
        this.maxR = r;
        this.r = 10;
        this.life = 0.5;
        this.maxLife = 0.5;
    }
    update(dt) {
        this.life -= dt;
        this.r += (this.maxR - this.r) * 10 * dt;
    }
    draw(ctx) {
        const opacity = Math.max(0, this.life / this.maxLife);
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = `rgba(255, 100, 0, 0.3)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = `rgba(255, 200, 50, 0.8)`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class Entity {
    constructor(x, y, r, color) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.color = color;
        this.vx = 0;
        this.vy = 0;
        this.ax = 0;
        this.ay = 0;
        this.friction = 0.9;
        this.health = 100;
        this.maxHealth = 100;
        this.dead = false;
        this.team = 'neutral';
        this.pushability = 1;
        this.bodyDamage = 10;
        this.animState = Math.random() * 100;
        this.trait = null; 
    }

    update(dt) {
        this.vx += this.ax * dt;
        this.vy += this.ay * dt;
        this.vx *= Math.pow(this.friction, dt * 60);
        this.vy *= Math.pow(this.friction, dt * 60);
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.ax = 0; this.ay = 0;
        
        // Reset friction (default land)
        this.friction = 0.9;

        // Terrain Effects
        const tx = Math.floor(this.x / CONFIG.gridSize);
        const ty = Math.floor(this.y / CONFIG.gridSize);
        if (terrainGrid && terrainGrid[tx] && terrainGrid[tx][ty] !== undefined) {
            const tile = terrainGrid[tx][ty];
            
            if (tile === TILES.LAVA) {
                if (this instanceof Dino) {
                    this.takeDamage(dt * 30, null, 'lava');
                } else {
                    this.health -= dt * 50; // Shapes burn
                }
            } else if (tile === TILES.WATER) {
                this.vx *= 0.95; // Sluggish movement
                this.vy *= 0.95;
            } else if (tile === TILES.ICE || tile === TILES.FROZEN_LAVA) {
                this.friction = 0.99; // Slippery
            }
        }

        const speed = Math.hypot(this.vx, this.vy);
        this.animState += dt * (speed * 0.05 + 2);

        if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
        if (this.y < 0) { this.y = 0; this.vy *= -0.5; }
        if (this.x > CONFIG.mapWidth) { this.x = CONFIG.mapWidth; this.vx *= -0.5; }
        if (this.y > CONFIG.mapHeight) { this.y = CONFIG.mapHeight; this.vy *= -0.5; }

        if (this.health <= 0) this.die();
    }

    draw(ctx) {
        if (this.health < this.maxHealth) {
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x - this.r, this.y + this.r + 8, this.r * 2, 4);
            ctx.fillStyle = '#8f8';
            ctx.fillRect(this.x - this.r, this.y + this.r + 8, (this.r * 2) * (this.health / this.maxHealth), 4);
        }
    }

    takeDamage(amount, source, type) {
        let finalDamage = amount;
        let isResisted = false;
        let isEffective = false;

        if (this.trait) {
            switch (this.trait) {
                case 'armored': 
                    if (['standard', 'flame', 'missile'].includes(type)) { finalDamage *= 0.2; isResisted = true; }
                    else if (['laser', 'bomb', 'tesla'].includes(type)) { finalDamage *= 1.5; isEffective = true; }
                    break;
                case 'evasive': 
                    if (['bomb', 'missile'].includes(type)) { finalDamage *= 0.2; isResisted = true; }
                    else if (['laser', 'tesla', 'standard'].includes(type)) { finalDamage *= 1.5; isEffective = true; }
                    break;
                case 'ablative': 
                    if (['laser', 'flame', 'tesla'].includes(type)) { finalDamage *= 0.2; isResisted = true; }
                    else if (['standard', 'bomb', 'missile'].includes(type)) { finalDamage *= 1.5; isEffective = true; }
                    break;
                case 'spiked':
                    if (type === 'melee' && source) { source.takeDamage(this.bodyDamage * 0.5, this, 'reflected'); isResisted = true; }
                    else if (['standard', 'laser', 'flame', 'bomb', 'missile'].includes(type)) { finalDamage *= 1.2; isEffective = true; }
                    break;
            }
        }

        this.health -= finalDamage;
        let color = 'white'; let size = 12;
        if (isResisted) { color = '#aaa'; size = 10; }
        if (isEffective) { color = '#f55'; size = 16; }
        
        spawnDamageNumber(this.x, this.y, Math.round(finalDamage), color, size);
        
        // Audio: Only play hit sound if player is involved to prevent spam
        if (this.health > 0) {
            if (this.isPlayer || (source && source.isPlayer)) {
                AudioSys.hit();
            }
        }
        
        if (this.health <= 0 && !this.dead) {
            this.dead = true;
            if (source && source instanceof Dino && source.isPlayer) source.gainXp(this.xpValue || 10);
            this.onDeath(source);
        }
    }

    die() { this.dead = true; }
    
    onDeath(source) {
        if (this instanceof Dino) AudioSys.die();
        else AudioSys.hit();
        for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, this.color));
    }
}

const POWERUP_TYPES = {
    'health': { color: '#44ff44', label: 'â¤', duration: 0, r: 15 },
    'frenzy': { color: '#ff0000', label: 'âš¡', duration: 10, r: 18 }, // Double Fire Rate
    'shield': { color: '#00ffff', label: 'ðŸ›¡', duration: 8, r: 18 }, // Invulnerability
    'speed':  { color: '#ffff00', label: 'â©', duration: 12, r: 15 }, // +50% Speed
    'tiny':   { color: '#ff00ff', label: 'ðŸœ', duration: 15, r: 15 }, // Small size + Evasion
    'xp':     { color: '#7b00ff', label: 'â˜…', duration: 0, r: 14 },  // Big XP Chunk
    'life':   { color: '#00ff88', label: '1UP', duration: 0, r: 18 } // Extra Life (Run)
};

class PowerUp extends Entity {
    constructor(x, y, type) {
        super(x, y, POWERUP_TYPES[type].r, POWERUP_TYPES[type].color);
        this.type = type;
        this.data = POWERUP_TYPES[type];
        this.bobOffset = rand(0, Math.PI * 2);
    }

    update(dt) {
        this.bobOffset += dt * 3;
        // Float animation
        this.scale = 1.0 + Math.sin(this.bobOffset) * 0.2;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const s = this.scale;
        
        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        if (this.type === 'health') {
            // Heart shape approximation or Cross
            ctx.fillRect(-this.r*0.6*s, -this.r*0.2*s, this.r*1.2*s, this.r*0.4*s);
            ctx.fillRect(-this.r*0.2*s, -this.r*0.6*s, this.r*0.4*s, this.r*1.2*s);
        } else if (this.type === 'shield') {
            ctx.beginPath(); ctx.arc(0, 0, this.r*s, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.r*s, 0, Math.PI*2); ctx.fill();
        }
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 0;
        ctx.fillText(this.data.label, 0, 0);

        // Ring
        ctx.strokeStyle = `rgba(255,255,255,${0.5 + Math.sin(this.bobOffset)*0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.r * s * 1.3, 0, Math.PI*2);
        ctx.stroke();

        ctx.restore();
    }
}

class Shape extends Entity {
    constructor(type, x, y, sizeVariance = 1.0) {
        super(x, y, 10, '#fff');
        this.type = type;
        this.angle = 0;
        this.rotationSpeed = 0; 
        this.sizeVariance = sizeVariance;
        
        let baseR = 10; let baseHp = 10; let baseXp = 10;
        if (type === 'egg') { baseR = 12; this.color = '#ffe869'; baseHp = 10; baseXp = 30; this.sides = 4; }
        else if (type === 'plant') { baseR = 18; this.color = '#76fc77'; baseHp = 30; baseXp = 100; this.sides = 5; } 
        else if (type === 'fossil') { baseR = 24; this.color = '#e0e0d0'; baseHp = 100; baseXp = 400; this.sides = 5; } 
        else if (type === 'amber') { baseR = 30; this.color = '#ff8c00'; baseHp = 250; baseXp = 800; this.sides = 8; }
        else if (type === 'alpha_fossil') { baseR = 55; this.color = '#a0a090'; baseHp = 3000; baseXp = 10000; this.sides = 5; this.pushability = 0.01; this.bodyDamage = 40; }

        this.r = baseR * sizeVariance;
        this.health = baseHp * sizeVariance;
        this.maxHealth = this.health;
        this.xpValue = baseXp * sizeVariance;
        this.ax = rand(-5, 5); this.ay = rand(-5, 5); this.friction = 0.98;
    }

    update(dt) {
        // Magnet Logic
        if (!player.dead) {
             const dx = player.x - this.x;
             const dy = player.y - this.y;
             const dist = Math.sqrt(dx*dx + dy*dy);
             
             // Only pull if within radius AND player is big enough to eat it
             if (dist < (player.pickupRadius || 150) && player.r > this.r * 1.15) {
                 const pullStrength = 1500 * (1 - dist / (player.pickupRadius || 150));
                 const angle = Math.atan2(dy, dx);
                 this.ax += Math.cos(angle) * pullStrength;
                 this.ay += Math.sin(angle) * pullStrength;
                 this.friction = 0.85; 
             } else {
                 this.friction = 0.98; 
             }
        }

        super.update(dt);
        
        if (this.type === 'alpha_fossil') {
            const dx = this.x - CONFIG.mapWidth/2;
            const dy = this.y - CONFIG.mapHeight/2;
            const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist > CONFIG.nestRadius) { this.ax -= dx * 0.01; this.ay -= dy * 0.01; }
        }
    }

    onDeath(source) {
        super.onDeath(source);
    }

    draw(ctx) {
        super.draw(ctx);
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.type === 'amber') {
            const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
            ctx.beginPath();
            ctx.arc(0, 0, 250 * this.sizeVariance * pulse, 0, Math.PI * 2); 
            ctx.strokeStyle = `rgba(255, 140, 0, 0.2)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        const useImage = lootImage.complete && lootImage.naturalWidth > 0;
        
        if (useImage) {
            const tW = lootImage.naturalWidth / 2;
            const tH = lootImage.naturalHeight / 2;
            
            let sx = 0, sy = 0;
            if (this.type === 'egg') { sx = 0; sy = 0; }
            else if (this.type === 'plant') { sx = tW; sy = 0; }
            else if (this.type === 'fossil' || this.type === 'alpha_fossil') { sx = 0; sy = tH; }
            else if (this.type === 'amber') { sx = tW; sy = tH; }
            
            const size = this.r * 2.3; 
            
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = camera.zoom < 0.6 ? 0 : 10;
            
            ctx.drawImage(lootImage, sx, sy, tW, tH, -size/2, -size/2, size, size);
            ctx.shadowBlur = 0;
        } else {
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = camera.zoom < 0.6 ? 0 : 10;
            ctx.fillStyle = this.color;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (this.type === 'egg') ctx.rect(-this.r + 2, -this.r + 2, this.r*2 - 4, this.r*2 - 4);
            else if (this.type === 'plant') {
                 for (let i = 0; i < this.sides; i++) {
                    const angle = (i * 2 * Math.PI) / this.sides;
                    const nextAngle = ((i + 1) * 2 * Math.PI) / this.sides;
                    const midAngle = (angle + nextAngle) / 2;
                    ctx.lineTo(this.r * Math.cos(angle), this.r * Math.sin(angle));
                    ctx.lineTo(this.r * 0.4 * Math.cos(midAngle), this.r * 0.4 * Math.sin(midAngle));
                 }
                 ctx.closePath();
            }
            else {
                ctx.moveTo(this.r, 0);
                for (let i = 1; i < this.sides; i++) {
                    const angle = (i * 2 * Math.PI) / this.sides;
                    ctx.lineTo(this.r * Math.cos(angle), this.r * Math.sin(angle));
                }
                ctx.closePath();
            }
            ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            if (this.type === 'egg') { ctx.rect(-this.r * 0.5, -this.r * 0.5, this.r, this.r * 0.2); }
            else if (this.type === 'plant') { ctx.arc(0,0, this.r*0.3, 0, Math.PI*2); }
            else {
                const innerR = this.r * 0.6;
                ctx.moveTo(innerR, 0);
                for (let i = 1; i < this.sides; i++) {
                    const angle = (i * 2 * Math.PI) / this.sides;
                    ctx.lineTo(innerR * Math.cos(angle), innerR * Math.sin(angle));
                }
                ctx.closePath();
            }
            ctx.fill();
        }
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(owner, x, y, angle, speed, damage, size, pen, life, type) {
        super(x, y, size, owner.color);
        this.owner = owner;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.damage = damage;
        this.penetrationHp = 10 + (pen * 10); 
        this.life = life;
        this.friction = 1.0;
        this.team = owner.team;
        this.type = type || 'standard';
        
        // Animation
        this.animFrame = 0;
        this.animTimer = 0;

        if (this.type === 'laser') { this.vx *= 3; this.vy *= 3; this.color = '#0ff'; this.penetrationHp = 1000; this.life = 0.5; }
        else if (this.type === 'bomb') { this.vx *= 0.4; this.vy *= 0.4; this.r *= 2.5; this.life = 3.0; this.damage *= 3; this.color = '#333'; }
        else if (this.type === 'flame') {
            this.friction = 0.92; 
            this.life = 2.0 + (this.owner.tier || 0) * 1.0;     
            const fireColors = ['#ff0000', '#ff4500', '#ff8c00', '#ffd700'];
            this.color = fireColors[Math.floor(Math.random() * fireColors.length)];
            this.r *= 1.5; this.penetrationHp = 1000; 
            const spread = (Math.random() - 0.5) * 0.5; const speedVar = 1.0 + (Math.random() * 0.4); 
            const originalAngle = Math.atan2(this.vy, this.vx);
            const finalAngle = originalAngle + spread;
            const currentSpeed = Math.hypot(this.vx, this.vy) * speedVar;
            this.vx = Math.cos(finalAngle) * currentSpeed; this.vy = Math.sin(finalAngle) * currentSpeed;
        } else if (this.type === 'missile') { this.vx *= 0.6; this.vy *= 0.6; this.life = 3.0; this.color = '#f00'; }
        else if (this.type === 'lightning') { this.life = 0.2; this.damage *= 0.5; }
    }

    update(dt) {
        // Animation Step
        this.animTimer += dt;
        if (this.animTimer > 0.08) {
            this.animTimer = 0;
            this.animFrame = (this.animFrame + 1) % 4;
        }
    
        if (this.type === 'missile') {
            let target = null; let minDist = 600;
            for(let e of entities) {
                if (e.dead || e.team === this.team || e instanceof Bullet || e instanceof Particle) continue;
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minDist) { minDist = d; target = e; }
            }
            if (target) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                this.vx += Math.cos(angle) * 50; this.vy += Math.sin(angle) * 50;
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 600) { this.vx = (this.vx/speed)*600; this.vy = (this.vy/speed)*600; }
            }
        } else if (this.type === 'flame') { this.r += 12 * dt; }

        this.x += this.vx * dt; this.y += this.vy * dt;
        this.vx *= Math.pow(this.friction, dt * 60); this.vy *= Math.pow(this.friction, dt * 60);
        this.life -= dt;
        if (this.life <= 0 || this.x < 0 || this.x > CONFIG.mapWidth || this.y < 0 || this.y > CONFIG.mapHeight) {
            this.dead = true;
            if (this.type === 'bomb') { createExplosion(this.x, this.y, this.damage, this.r * 4, this.owner); }
        }
    }

    draw(ctx) {
        if (this.type === 'laser') {
            ctx.strokeStyle = this.color; ctx.lineWidth = this.r; ctx.lineCap = 'round'; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.vx * 0.1, this.y - this.vy * 0.1); ctx.stroke(); ctx.shadowBlur = 0;
            return;
        }

        const useImage = projectileImage.complete && projectileImage.naturalWidth > 0;
        
        if (useImage) {
            const frameW = 704 / 4;
            const frameH = 384 / 4;
            
            let row = 0;
            if (this.type === 'standard') row = 0;
            else if (this.type === 'missile') row = 1;
            else if (this.type === 'bomb') row = 2;
            else if (this.type === 'flame') row = 3; 
            else row = 0;

            const angle = Math.atan2(this.vy, this.vx);
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(angle);
            
            // Adjust size based on projectile type
            const scale = (this.r * 3) / frameH; 
            const drawW = frameW * scale;
            const drawH = frameH * scale;

            ctx.drawImage(projectileImage, this.animFrame * frameW, row * frameH, frameW, frameH, -drawW/2, -drawH/2, drawW, drawH);
            
            ctx.restore();
        } else {
             // Fallback
             ctx.beginPath();
             if (this.type === 'bomb') {
                const pulse = 1 + Math.sin(Date.now() * 0.02) * 0.2;
                ctx.arc(this.x, this.y, this.r * pulse, 0, Math.PI * 2);
                ctx.fillStyle = '#444'; 
                ctx.fill();
                ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r*0.4, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                if (this.type === 'flame') { 
                    ctx.globalAlpha = Math.max(0, this.life / 0.8); 
                }
                ctx.fill();
                ctx.globalAlpha = 1; 
            }
        }
    }
    
    hitSomething() {
        this.penetrationHp -= 12; 
        if (this.penetrationHp <= 0) {
            this.dead = true;
            if (this.type === 'bomb') { createExplosion(this.x, this.y, this.damage, this.r * 4, this.owner); }
        } else {
            if (this.type !== 'laser' && this.type !== 'flame') this.r *= 0.9;
        }
    }
}

class Dino extends Entity {
    constructor(x, y, isPlayer = false) {
        super(x, y, 20, isPlayer ? '#00e1b2' : '#ff5500'); // Jungle Teal / Danger Orange
        this.isPlayer = isPlayer;
        this.angle = 0;
        this.stats = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // 9 Stats
        
        this.invulnerableTimer = 0;

        this.level = 1;
        this.tier = 0; 
        this.xp = 0;
        this.score = 0; 
        this.maxXp = 50;
        this.points = 0;
        this.reloadTimer = 0;
        this.regenTimer = 0;
        this.teslaTimer = 0;
        
        this.className = "Baby Dino";
        this.team = this.className; // Species-based Teams
        this.classDef = CLASS_DEFS['Baby Dino'];
        this.guns = JSON.parse(JSON.stringify(this.classDef.guns)); 
        this.scaleMult = this.classDef.scale;
        
        this.bonusGunCount = 0; 
        this.weaponSizeMult = 1.0; 
        this.fireRateMult = 1.0;
        
        this.orbitals = [];
        this.hasTesla = false;
        this.teslaPower = 0;
        this.activeEffects = [];
        this.upgradesTaken = [];

        // Pattern Generation
        this.patternSeed = Math.random();
        this.patternType = Math.random() > 0.5 ? 'stripes' : 'spots';

        if (!isPlayer) {
            const maxLvl = Math.max(1, Math.min(200, player.level + 5)); 
            this.level = Math.floor(rand(1, maxLvl));
            this.assignAIClass();
            for(let i=0; i<8; i++) this.stats[i] = rand(0, this.level/3);
            this.recalcStats();
            this.health = this.maxHealth;
            this.aiDirTimer = 0;
            this.targetLockedTimer = 0;
            this.aiState = 'roam';
            this.aiStateTimer = 0;
            this.strafeDir = Math.random() < 0.5 ? -1 : 1;
            this.strafeTimer = rand(0.6, 1.4);
        }
    }

    assignAIClass() {
        if (this.level >= 45) {
            const opts = Object.keys(CLASS_DEFS).filter(k => CLASS_DEFS[k].tier === 3);
            this.evolve(opts[Math.floor(Math.random() * opts.length)]);
            if (this.level > 60) {
               if (Math.random() < 0.3) this.addBonusGun('standard');
               if (Math.random() < 0.3) { this.scaleMult *= 1.3; this.recalcStats(); }
            }
        } else if (this.level >= 30) {
            const opts = Object.keys(CLASS_DEFS).filter(k => CLASS_DEFS[k].tier === 2);
            this.evolve(opts[Math.floor(Math.random() * opts.length)]);
        } else {
            // Level 1-29: Chance to be Tier 1 (Diversity)
            // 30% chance to stay Baby Dino, 70% chance to be a Tier 1 species
            if (Math.random() < 0.3 && this.level < 15) return; 
            
            const opts = Object.keys(CLASS_DEFS).filter(k => CLASS_DEFS[k].tier === 1);
            this.evolve(opts[Math.floor(Math.random() * opts.length)]);
        }
    }

    recalcStats() {
        // Apply Active Effects
        let speedMult = 1.0;
        let reloadMult = 1.0;
        let damageMult = 1.0;
        let sizeMod = 1.0;

        this.activeEffects.forEach(e => {
            if (e.type === 'speed') speedMult *= 1.5;
            if (e.type === 'frenzy') reloadMult *= 0.5;
            if (e.type === 'tiny') sizeMod *= 0.6;
        });

        const sizeBonus = this.level * 0.6;
        this.r = (20 + sizeBonus) * this.scaleMult * sizeMod;

        this.maxHealth = 50 + (this.level * 2) + (this.stats[1] * 20);
        this.regenRate = 0.05 + (this.stats[0] * 0.1); 
        this.bodyDamage = 20 + (this.stats[2] * 4) + (this.level * 0.5); 
        this.moveSpeed = (200 + (this.stats[7] * 15)) * (1 / Math.sqrt(this.scaleMult * sizeMod)) * speedMult; 
        this.bulletSpeed = 300 + (this.stats[3] * 30);
        this.bulletPen = 10 + (this.stats[4] * 10);
        this.bulletDmg = (5 + (this.stats[5] * 3)) * damageMult;
        
        this.pickupRadius = 150 + (this.r) + (this.stats[8] * 60); // Magnet
        
        this.reloadTime = 0.6 * Math.pow(0.93, this.stats[6]);
        this.reloadTime /= (this.fireRateMult / reloadMult); 

        if (!this.isPlayer && !this.isBoss) {
            this.bulletDmg *= 0.2; 
            this.maxHealth *= 0.8;  
            this.bodyDamage *= 0.4; 
        }

        if (this.guns.some(g => g.type === 'flame')) {
            this.reloadTime *= 0.15; 
            this.bulletDmg *= 0.4;   
        }
        
        if (this.isPlayer) {
            // Resolution-independent zoom: Aim to show ~1920 units horizontally at base size
            // As player grows, zoom out slightly (less aggressively than before)
            const baseViewWidth = 1920;
            const sizeFactor = Math.pow(30 / Math.max(30, this.r), 0.7); // 0.7 power for milder zoom out
            
            let target = (width / baseViewWidth) * sizeFactor;
            
            // Hard clamp: Never show more than 3500 units horizontally to prevent "seeing everything"
            // width / zoom < 3500  =>  zoom > width / 3500
            target = Math.max(target, width / 3500);
            
            camera.targetZoom = target; 
        }
    }

    applyPowerUp(type) {
        const data = POWERUP_TYPES[type];
        if (!data) return;
        
        // Instant Effects
        if (type === 'health') {
            this.health = Math.min(this.maxHealth, this.health + this.maxHealth * 0.5);
            spawnDamageNumber(this.x, this.y, "HP UP", '#0f0', 20);
            return;
        }
        if (type === 'xp') {
            this.gainXp(this.maxXp * 0.5); // 50% of current level
            spawnDamageNumber(this.x, this.y, "XP UP", '#7b00ff', 20);
            return;
        }
        if (type === 'life') {
            if (runState.lives < RUN_CONFIG.maxLives) {
                runState.lives++;
                spawnDamageNumber(this.x, this.y, "1UP", '#00ff88', 22);
                showNotification("Extra Life!");
                updateHud();
            } else {
                spawnDamageNumber(this.x, this.y, "MAX", '#00ff88', 16);
            }
            return;
        }

        // Temporary Effects
        // Check if already active, if so, extend duration
        const existing = this.activeEffects.find(e => e.type === type);
        if (existing) {
            existing.timer = data.duration;
        } else {
            this.activeEffects.push({ type: type, timer: data.duration });
            this.recalcStats();
            spawnDamageNumber(this.x, this.y, data.label + "!", data.color, 24);
        }
    }

    gainXp(amount) {
        this.xp += amount;
        this.score += amount;
        if (this.isPlayer) runState.score = this.score;
        if (this.xp >= this.maxXp) {
            this.levelUp();
        }
        updateHud();
    }

    levelUp() {
        AudioSys.levelUp();
        this.xp -= this.maxXp;
        this.level++;
        this.maxXp = 50 * Math.pow(1.10, this.level - 1); 
        if (this.maxXp > 500000) this.maxXp = 500000;
        
        this.points++;
        this.recalcStats();
        this.health = this.maxHealth;
        
        showNotification(`Level Up! Lvl ${this.level}`);
        updateUpgradeUi();
        checkWeaponUpgrades();
    }

    evolve(className) {
        const def = CLASS_DEFS[className];
        if (!def) return;
        this.className = className;
        this.team = className; // Team = Species
        this.classDef = def;
        this.scaleMult = def.scale;
        
        this.tier = def.tier;
        
        const baseGuns = JSON.parse(JSON.stringify(def.guns));
        
        const currentBonusGuns = this.guns.slice(this.guns.length - this.bonusGunCount);
        this.guns = baseGuns.concat(currentBonusGuns);
        
        this.recalcStats();
    }
    
    addBonusGun(type, reapply = false) {
        if (!reapply) this.bonusGunCount++;
        
        const types = ['standard', 'laser', 'flame', 'bomb'];
        const gunType = type || types[Math.floor(Math.random() * types.length)];
        
        this.guns.push({
            a: Math.random() * Math.PI * 2, 
            x: 0, y: 0, 
            w: 0.4, h: 1.3, 
            type: gunType
        });
    }

    update(dt) {
        // Update Effects
        if (this.activeEffects.length > 0) {
            let changed = false;
            for (let i = this.activeEffects.length - 1; i >= 0; i--) {
                this.activeEffects[i].timer -= dt;
                if (this.activeEffects[i].timer <= 0) {
                    this.activeEffects.splice(i, 1);
                    changed = true;
                }
            }
            if (changed) this.recalcStats();
        }

        if (this.invulnerableTimer > 0) this.invulnerableTimer -= dt;

        if (this.health < this.maxHealth) {
            this.regenTimer += dt;
            if (this.regenTimer > 1) {
                this.health += this.regenRate;
                if (this.health > this.maxHealth) this.health = this.maxHealth;
            }
        }
        
        if (this.hasTesla) {
            this.teslaTimer -= dt;
            if (this.teslaTimer <= 0) {
                this.teslaTimer = 1.0;
                let target = null;
                let minDist = 300 * (1 + this.teslaPower*0.2);
                for(let e of entities) {
                    if (e.dead || e.team === this.team || e instanceof Bullet) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) { minDist = d; target = e; }
                }
                if (target) {
                    particles.push(new LightningBolt(this.x, this.y, target.x, target.y));
                    target.takeDamage(this.bodyDamage * (1 + this.teslaPower), this, 'tesla');
                }
            }
        }
        
        if (this.orbitals && this.orbitals.length > 0) {
            this.orbitals.forEach(orb => {
                orb.angle += dt * 2;
                orb.realX = this.x + Math.cos(orb.angle) * (this.r + orb.dist);
                orb.realY = this.y + Math.sin(orb.angle) * (this.r + orb.dist);
                
                for(let e of entities) {
                    if (e.dead || e.team === this.team || e instanceof Bullet) continue;
                    const d = Math.hypot(e.x - orb.realX, e.y - orb.realY);
                    if (d < e.r + orb.r) {
                        e.takeDamage(this.bodyDamage * 0.5, this, 'melee');
                        const a = Math.atan2(e.y - this.y, e.x - this.x);
                        e.vx += Math.cos(a) * 300; e.vy += Math.sin(a) * 300;
                    }
                }
            });
        }

        if (this.isPlayer) this.handlePlayerInput(dt);
        else this.handleAi(dt);

        super.update(dt); 
        
        this.reloadTimer -= dt;
        const wantsShoot = this.isPlayer ? (mouse.down || joystickRight.active) : this.aiShooting;
        
        if (wantsShoot && this.reloadTimer <= 0) {
            this.shoot();
            this.reloadTimer = this.reloadTime;
        }
    }

    handlePlayerInput(dt) {
        let dx = 0, dy = 0;
        if (keys['w'] || keys['ArrowUp']) dy -= 1;
        if (keys['s'] || keys['ArrowDown']) dy += 1;
        if (keys['a'] || keys['ArrowLeft']) dx -= 1;
        if (keys['d'] || keys['ArrowRight']) dx += 1;
        if (joystickLeft.active) { dx = joystickLeft.x; dy = joystickLeft.y; }

        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.ax = (dx/len) * this.moveSpeed * 5;
            this.ay = (dy/len) * this.moveSpeed * 5;
        }

        if (joystickRight.active) this.angle = Math.atan2(joystickRight.y, joystickRight.x);
        else {
            const worldMouseX = camera.x + (mouse.x / camera.zoom);
            const worldMouseY = camera.y + (mouse.y / camera.zoom);
            this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x);
        }
    }

    handleAi(dt) {
        if (this.isBoss) {
            this.handleBossAi(dt);
            return;
        }

        // --- FREE FOR ALL AI LOGIC ---
        let target = null;
        let minDist = 1100;

        // Find nearest enemy (different species)
        // Optimization: Check if player is near first, as they are priority for fun factor
        // But also check other dinos.
        
        const enemies = entities; // Can use spatial grid if performance becomes issue
        
        for (let i = 0; i < enemies.length; i++) {
             const e = enemies[i];
             if (e.dead || e === this) continue;
             if (!(e instanceof Dino)) continue;
             
             // Team check: Same species = friends
             if (e.team === this.team) continue;
             
             const d = Math.hypot(e.x - this.x, e.y - this.y);
             if (d < minDist) {
                 minDist = d;
                 target = e;
             }
        }
        
        const hasTarget = target !== null;
        let dist = minDist;
        let dx = 0, dy = 0;
        if (target) {
            dx = target.x - this.x;
            dy = target.y - this.y;
        }

        // Strafe behavior for ranged kiting
        this.strafeTimer -= dt;
        if (this.strafeTimer <= 0) {
            this.strafeTimer = rand(0.6, 1.6);
            if (Math.random() < 0.65) this.strafeDir *= -1;
        }

        if (!hasTarget) {
            this.aiState = 'roam';
            this.aiShooting = false;
            this.targetLockedTimer = 0;

            this.aiDirTimer -= dt;
            if (this.aiDirTimer <= 0) {
                this.aiDirTimer = rand(1.0, 2.8);
                const moveAngle = rand(0, Math.PI * 2);
                this.ax = Math.cos(moveAngle) * this.moveSpeed * 3;
                this.ay = Math.sin(moveAngle) * this.moveSpeed * 3;
            }
        } else {
            const invDist = 1 / Math.max(1, dist);
            const ux = dx * invDist;
            const uy = dy * invDist;

            // Fear logic: target is bigger OR health is low
            const fear = (target.r > this.r * 1.3) || (this.health < this.maxHealth * 0.25);
            this.aiState = fear ? 'flee' : (this.behavior === 'ranged' ? 'kite' : 'chase');

            this.angle = Math.atan2(dy, dx);

            // Shooting only if we're committed to the fight
            if (this.behavior === 'ranged' && !fear && this.guns && this.guns.length > 0) {
                this.targetLockedTimer += dt;
                this.aiShooting = this.targetLockedTimer > 0.35 && dist < 950;
            } else {
                this.aiShooting = false;
                this.targetLockedTimer = 0;
            }

            if (this.aiState === 'chase') {
                this.ax += ux * this.moveSpeed * 2.2;
                this.ay += uy * this.moveSpeed * 2.2;
            } else if (this.aiState === 'flee') {
                this.ax -= ux * this.moveSpeed * 2.8;
                this.ay -= uy * this.moveSpeed * 2.8;

                const px = -uy, py = ux;
                this.ax += px * this.moveSpeed * 1.4 * this.strafeDir;
                this.ay += py * this.moveSpeed * 1.4 * this.strafeDir;
            } else if (this.aiState === 'kite') {
                const desired = 420;
                const band = 90;

                if (dist > desired + band) {
                    this.ax += ux * this.moveSpeed * 1.8;
                    this.ay += uy * this.moveSpeed * 1.8;
                } else if (dist < desired - band) {
                    this.ax -= ux * this.moveSpeed * 2.4;
                    this.ay -= uy * this.moveSpeed * 2.4;
                }

                const px = -uy, py = ux;
                this.ax += px * this.moveSpeed * 1.9 * this.strafeDir;
                this.ay += py * this.moveSpeed * 1.9 * this.strafeDir;
            }
        }

        // Avoid stacking up (simple separation steering)
        if (spatialGrid && spatialGrid.query) {
            const near = spatialGrid.query(this);
            for (let i = 0; i < near.length; i++) {
                const o = near[i];
                if (!o || o === this || o.dead) continue;
                if (!(o instanceof Dino) || o.isPlayer || o.isBoss) continue;

                const rx = this.x - o.x;
                const ry = this.y - o.y;
                const d = Math.hypot(rx, ry);
                const minD = (this.r + o.r) * 1.05;
                if (d > 0 && d < minD) {
                    const push = (minD - d) / minD;
                    this.ax += (rx / d) * this.moveSpeed * 2.2 * push;
                    this.ay += (ry / d) * this.moveSpeed * 2.2 * push;
                }
            }

            // Evasive trait: dodge nearby bullets (quick lateral burst)
            if (this.trait === 'evasive') {
                for (let i = 0; i < near.length; i++) {
                    const o = near[i];
                    if (!(o instanceof Bullet) || o.dead) continue;
                    if (o.team === this.team) continue;

                    const rx = this.x - o.x;
                    const ry = this.y - o.y;
                    const d = Math.hypot(rx, ry);
                    if (d > 260) continue;

                    const toward = (rx * o.vx + ry * o.vy) > 0;
                    if (!toward) continue;

                    const bv = Math.hypot(o.vx, o.vy) || 1;
                    const px = -o.vy / bv;
                    const py = o.vx / bv;
                    const side = Math.sign(rx * px + ry * py) || 1;
                    this.ax += px * side * this.moveSpeed * 3.0;
                    this.ay += py * side * this.moveSpeed * 3.0;
                    break;
                }
            }
        }

        // Lava escape (strong bias to step off lava tiles)
        const tile = getTileAtWorld(this.x, this.y);
        if (tile === TILES.LAVA) {
            const tx = Math.floor(this.x / CONFIG.gridSize);
            const ty = Math.floor(this.y / CONFIG.gridSize);
            const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
            let best = null;
            for (let i = 0; i < dirs.length; i++) {
                const nx = tx + dirs[i][0];
                const ny = ty + dirs[i][1];
                if (!terrainGrid[nx] || terrainGrid[nx][ny] === undefined) continue;
                const t = terrainGrid[nx][ny];
                if (t === TILES.LAVA) continue;
                const cx = (nx + 0.5) * CONFIG.gridSize;
                const cy = (ny + 0.5) * CONFIG.gridSize;
                best = { x: cx, y: cy };
                break;
            }
            if (best) {
                const a = Math.atan2(best.y - this.y, best.x - this.x);
                this.ax += Math.cos(a) * this.moveSpeed * 6;
                this.ay += Math.sin(a) * this.moveSpeed * 6;
            }
        }
    }

    handleBossAi(dt) {
        const arena = bossArena || { x: CONFIG.mapWidth / 2, y: CONFIG.mapHeight / 2, r: CONFIG.nestRadius };
        const distToCenter = Math.hypot(this.x - arena.x, this.y - arena.y);
        if (distToCenter > arena.r + 200) {
            const angle = Math.atan2(arena.y - this.y, arena.x - this.x);
            this.ax = Math.cos(angle) * this.moveSpeed * 5;
            this.ay = Math.sin(angle) * this.moveSpeed * 5;
        } else {
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < 1000) {
                this.angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.aiShooting = true;
                if (dist > 400) {
                    this.ax += Math.cos(this.angle) * 100;
                    this.ay += Math.sin(this.angle) * 100;
                }
            } else {
                this.aiShooting = false;
                this.angle += 0.01;
            }
        }
    }

    shoot() {
        if (!this.guns) return;

        let shotFired = false;
        this.guns.forEach(gun => {
            if (gun.delay && Math.random() < gun.delay) return;
            
            shotFired = true;
            const realAngle = this.angle + gun.a;
            this.vx -= Math.cos(realAngle) * 20 * gun.w;
            this.vy -= Math.sin(realAngle) * 20 * gun.w;
            
            // Calculate barrel tip position in Local Space (u, v)
            // gun.x is forward offset, gun.y is side offset
            // gun.h is barrel length
            
            const u = gun.x + Math.cos(gun.a) * gun.h;
            const v = gun.y + Math.sin(gun.a) * gun.h;
            
            // Rotate (u, v) by this.angle to get World Space offset
            // Standard rotation: x' = x cos - y sin, y' = x sin + y cos
            // Note: v (side) is usually negative for left? In canvas y is down.
            // Let's assume standard math.
            
            const dx = (u * Math.cos(this.angle) - v * Math.sin(this.angle));
            const dy = (u * Math.sin(this.angle) + v * Math.cos(this.angle));
            
            const bx = this.x + dx * this.r;
            const by = this.y + dy * this.r;
            
            let spread = 0;
            if (this.className === 'Dilophosaur' || this.className === 'Gunner') spread = (Math.random()-0.5) * 0.4;

            const b = new Bullet(
                this, bx, by, realAngle + spread, 
                this.bulletSpeed, this.bulletDmg * (this.isBoss ? 2 : 1), 
                this.r * 0.4 * gun.w * this.weaponSizeMult, 
                this.bulletPen, 2.0, gun.type
            );
            entities.push(b);
        });
        
        if (shotFired && this.isPlayer && this.guns.length > 0) AudioSys.shoot(this.guns[0].type);
    }

    draw(ctx) {
        if (this.invulnerableTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // --- 1. ROTATED LAYER (Guns & Traits) ---
        // These must follow the aim angle
        ctx.save();
        ctx.rotate(this.angle);

        // TRAIT VISUALS
        if (this.trait) {
            ctx.lineWidth = 4;
            if (this.trait === 'armored') {
                ctx.strokeStyle = '#8899aa'; 
                ctx.beginPath(); ctx.arc(0,0, this.r + 5, 0, Math.PI*2); ctx.stroke();
            } else if (this.trait === 'evasive') {
                ctx.strokeStyle = '#39ff14'; 
                ctx.beginPath(); ctx.setLineDash([10, 10]); ctx.arc(0,0, this.r + 5, Date.now()/100, Date.now()/100 + Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
            } else if (this.trait === 'ablative') {
                ctx.strokeStyle = '#ffffff'; 
                ctx.beginPath(); ctx.arc(0,0, this.r + 5, 0, Math.PI*2); ctx.stroke();
            } else if (this.trait === 'spiked') {
                ctx.strokeStyle = '#aa0000'; 
                for(let i=0; i<8; i++) {
                    const a = (i/8)*Math.PI*2;
                    ctx.beginPath(); ctx.moveTo(Math.cos(a)*this.r, Math.sin(a)*this.r); ctx.lineTo(Math.cos(a)*(this.r+10), Math.sin(a)*(this.r+10)); ctx.stroke();
                }
            }
        }

        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = camera.zoom < 0.6 ? 0 : 10;

        if (this.guns) {
            this.guns.forEach(gun => {
                ctx.save();
                ctx.rotate(gun.a);
                ctx.translate(gun.x * this.r, gun.y * this.r);
                ctx.fillStyle = '#777';
                if (gun.type === 'laser') ctx.fillStyle = '#0cc';
                if (gun.type === 'flame') ctx.fillStyle = '#c50';
                if (gun.type === 'bomb') ctx.fillStyle = '#333';
                
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                const w = this.r * gun.w * 2 * this.weaponSizeMult; 
                const h = this.r * gun.h;
                ctx.fillRect(0, -w/2, h, w);
                ctx.strokeRect(0, -w/2, h, w);
                ctx.restore();
            });
        }
        
        ctx.restore(); // END ROTATED LAYER

        // --- SPRITE SELECTION ---
        let spriteImg = null;
        // Check Bosses First
        if (this.isBoss) {
             if (this.name.includes('Guardian')) spriteImg = triceratopsImage;
             else if (this.name.includes('Destroyer')) spriteImg = trexImage;
             else if (this.name.includes('Titan')) spriteImg = titanosaurImage;
             else if (this.name.includes('Prism')) spriteImg = spinosaurusImage;
             else if (this.name.includes('Brood')) spriteImg = indominusImage;
             else spriteImg = trexImage; // Generic boss fallback
        }
        
        // Standard Classes
        if (!spriteImg) {
            if (this.className.includes('Baby')) spriteImg = babyDinoImage;
            else if (this.className.includes('Raptor')) spriteImg = raptorImage;
            else if (this.className.includes('Diloph')) spriteImg = dilophosaurImage;
            else if (this.className.includes('Stego')) spriteImg = stegosaurusImage;
            else if (this.className.includes('Pterodactyl')) spriteImg = pterodactylImage;
            else if (this.className.includes('Tri')) spriteImg = triceratopsImage;
            else if (this.className.includes('Giga')) spriteImg = giganotosaurusImage;
            else if (this.className.includes('Spino')) spriteImg = spinosaurusImage;
            else if (this.className.includes('Archaeo')) spriteImg = archaeopteryxImage;
            else if (this.className.includes('Titan')) spriteImg = titanosaurImage;
            else if (this.className.includes('Indom')) spriteImg = indominusImage;
            else if (this.className.includes('Rex')) spriteImg = trexImage;
            else if (this.className.includes('Veloci')) spriteImg = velociraptorImage;
        }

        // Final fallback
        if (!spriteImg) spriteImg = babyDinoImage;

        if (spriteImg && spriteImg.complete && spriteImg.naturalWidth > 0) {
            // --- SPRITE RENDERING ---
            // Orient based on velocity (Left/Right)
            let facingLeft = false;
            
            // Prioritize velocity if moving
            if (Math.abs(this.vx) > 10) {
                facingLeft = this.vx < 0;
            } else {
                // Fallback to aim if idle, to prevent freezing in wrong direction
                facingLeft = Math.abs(this.angle) > Math.PI / 2;
            }

            ctx.save();
            if (facingLeft) ctx.scale(-1, 1);

            let row = 0; // Idle
            const speed = Math.hypot(this.vx, this.vy);
            
            if (this.dead || this.health <= 0) row = 3;
            else if (this.invulnerableTimer > 0.5) row = 3;
            else if ((this.isPlayer && (mouse.down || joystickRight.active)) || this.aiShooting) row = 2; // Attack
            else if (speed > 50) row = 1; // Walk
            else row = 0; // Idle
            
            const frameW = 256;
            const frameH = 256;
            const frame = Math.floor(Date.now() / 150) % 4;
            
            // Scale: Map sprite height to dino size
            const drawH = this.r * 2.8;
            const drawW = drawH * (frameW / frameH);
            
            // Adjust offset to center
            ctx.drawImage(spriteImg, frame * frameW, row * frameH, frameW, frameH, -drawW * 0.55, -drawH/2, drawW, drawH);
            
            ctx.restore();
        } else {
             // Fallback for missing sprites (simple circle)
             ctx.fillStyle = this.color;
             ctx.beginPath();
             ctx.arc(0, 0, this.r, 0, Math.PI * 2);
             ctx.fill();
        }

        // --- DRAW ORBITALS (SAWS) ---
        if (this.orbitals && this.orbitals.length > 0) {
            this.orbitals.forEach(orb => {
                const ox = Math.cos(orb.angle) * (this.r + orb.dist);
                const oy = Math.sin(orb.angle) * (this.r + orb.dist);
                
                ctx.save();
                ctx.translate(ox, oy);
                ctx.rotate(Date.now() * 0.01); // Spin the saw itself
                
                ctx.fillStyle = '#888';
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                
                // Draw Saw Blade
                ctx.beginPath();
                const teeth = 8;
                for (let i = 0; i < teeth * 2; i++) {
                    const r = (i % 2 === 0) ? orb.r : orb.r * 0.6;
                    const a = (Math.PI * 2 * i) / (teeth * 2);
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            });
        }

        ctx.restore(); // Pop Top-Level Translation (this.x, this.y)

        if (this.health < this.maxHealth) {
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x - this.r, this.y + this.r + 8, this.r * 2, 4);
            ctx.fillStyle = '#8f8';
            ctx.fillRect(this.x - this.r, this.y + this.r + 8, (this.r * 2) * (this.health / this.maxHealth), 4);
        }
        
        if (this.name) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Ubuntu';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.name, this.x, this.y - this.r - 10);
            ctx.fillText(this.name, this.x, this.y - this.r - 10);
        }

        // Draw Active Effects
        if (this.activeEffects && this.activeEffects.length > 0) {
            let effX = this.x - ((this.activeEffects.length - 1) * 12);
            const effY = this.y - this.r - 30;
            this.activeEffects.forEach(e => {
                const d = POWERUP_TYPES[e.type];
                if (d) {
                    ctx.fillStyle = d.color;
                    ctx.font = '16px Arial';
                    ctx.fillText(d.label, effX, effY);
                    
                    // Tiny timer bar
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(effX - 8, effY + 2, 16, 3);
                    ctx.fillStyle = d.color;
                    ctx.fillRect(effX - 8, effY + 2, 16 * (e.timer / d.duration), 3);
                    
                    effX += 24;
                }
            });
        }

        ctx.globalAlpha = 1;
    }
    
    // Override takeDamage to detect player death
    takeDamage(amount, source, type) {
        if (this.invulnerableTimer > 0) return;
        if (this.activeEffects && this.activeEffects.some(e => e.type === 'shield')) {
             return; // Invulnerable
        }

        this.regenTimer = 0;
        
        const wasAlive = !this.dead;
        super.takeDamage(amount, source, type);
        
        if (this.isBoss) updateBossBar();
        
        if (this.isPlayer && wasAlive && this.dead) {
            handlePlayerDeath(source);
        }
    }
}

class LightningBolt {
    constructor(x1, y1, x2, y2) {
        this.x = x1; this.y = y1; // For culling
        this.x2 = x2; this.y2 = y2;
        this.life = 0.2;
    }
    update(dt) { this.life -= dt; }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.life * 5);
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + (this.x2 - this.x)*0.3 + (Math.random()-0.5)*20, this.y + (this.y2 - this.y)*0.3 + (Math.random()-0.5)*20);
        ctx.lineTo(this.x + (this.x2 - this.x)*0.7 + (Math.random()-0.5)*20, this.y + (this.y2 - this.y)*0.7 + (Math.random()-0.5)*20);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.angle = rand(0, Math.PI*2);
        this.speed = rand(50, 150);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = 0.5; this.r = rand(3, 6);
    }
    update(dt) { this.x += this.vx*dt; this.y += this.vy*dt; this.life -= dt; }
    draw(ctx) {
        ctx.globalAlpha = this.life*2; ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
        ctx.globalAlpha = 1;
    }
}

// --- Stage Objectives ---
class JewelObjective {
    constructor(jewelType, x, y) {
        this.kind = 'jewel';
        this.jewelType = jewelType;
        this.x = x;
        this.y = y;
        this.r = 22;
        this.t = rand(0, Math.PI * 2);
        this.dead = false;
    }
    update(dt) {
        this.t += dt * 3.5;
    }
    draw(ctx) {
        const pulse = 1 + Math.sin(this.t * 2.2) * 0.08;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(pulse, pulse);
        ctx.shadowBlur = 18;
        ctx.shadowColor = this.jewelType.color;
        ctx.fillStyle = this.jewelType.color;
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -this.r);
        ctx.lineTo(this.r * 0.75, 0);
        ctx.lineTo(0, this.r);
        ctx.lineTo(-this.r * 0.75, 0);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.beginPath();
        ctx.moveTo(0, -this.r * 0.75);
        ctx.lineTo(this.r * 0.35, 0);
        ctx.lineTo(0, this.r * 0.15);
        ctx.lineTo(-this.r * 0.35, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class GateObjective {
    constructor(x, y) {
        this.kind = 'gate';
        this.x = x;
        this.y = y;
        this.r = 90;
        this.unlocked = false;
        this.artifactRevealed = false;
        this.hintCooldown = 0;
    }
    update(dt) {
        if (this.hintCooldown > 0) this.hintCooldown -= dt;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const glow = this.unlocked ? 18 : 8;
        const color = this.unlocked ? '#7bffb3' : '#777';
        ctx.shadowBlur = glow;
        ctx.shadowColor = color;

        // Base
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(-this.r * 0.55, this.r * 0.15, this.r * 1.1, this.r * 0.35);

        // Arch
        ctx.strokeStyle = color;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(0, 0, this.r * 0.55, Math.PI, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-this.r * 0.55, 0);
        ctx.lineTo(-this.r * 0.55, this.r * 0.45);
        ctx.moveTo(this.r * 0.55, 0);
        ctx.lineTo(this.r * 0.55, this.r * 0.45);
        ctx.stroke();

        // Lock rune
        if (!this.unlocked) {
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffcc66';
            ctx.font = 'bold 18px Ubuntu';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('LOCKED', 0, this.r * 0.25);
        } else {
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = 'bold 18px Ubuntu';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('OPEN', 0, this.r * 0.25);
        }
        ctx.restore();
    }
}

class BossArtifactObjective {
    constructor(x, y) {
        this.kind = 'artifact';
        this.x = x;
        this.y = y;
        this.r = 32;
        this.t = rand(0, Math.PI * 2);
        this.dead = false;
    }
    update(dt) {
        this.t += dt * 4.0;
    }
    draw(ctx) {
        const pulse = 1 + Math.sin(this.t * 2.0) * 0.12;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(pulse, pulse);

        ctx.shadowBlur = 25;
        ctx.shadowColor = '#ff66ff';
        ctx.fillStyle = 'rgba(140, 60, 220, 0.8)';
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.arc(0, 0, this.r * 0.75, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = 'bold 14px Ubuntu';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('TOUCH', 0, 0);
        ctx.restore();
    }
}

class MosasaurThreat {
    constructor(config) {
        this.config = config;
        this.timeInWater = 0;
        this.cooldown = 0;
        this.warned = false;
        this.panicWarned = false;
        this.attack = null;
        this.t = rand(0, Math.PI * 2);
        this.inWaterPrev = false;
        this.stalking = false;
        this.safeThisEntry = false;
        this.danger = 0;
        this.noticeCooldown = 0;
        this.rollTimer = 0;
        this.beepTimer = 0;
        this.shadowAngle = rand(0, Math.PI * 2);
        this.shadowX = 0;
        this.shadowY = 0;
        this.source = { name: 'Mosasaur', takeDamage: () => {} };
    }

    reset() {
        this.timeInWater = 0;
        this.cooldown = 0;
        this.warned = false;
        this.panicWarned = false;
        this.attack = null;
        this.stalking = false;
        this.safeThisEntry = false;
        this.inWaterPrev = false;
        this.danger = 0;
        this.noticeCooldown = 0;
        this.rollTimer = 0;
        this.beepTimer = 0;
    }

    maybeNotify(text, chance = 1.0, cooldown = 3.0) {
        if (this.noticeCooldown > 0) return;
        if (Math.random() > chance) return;
        showNotification(text);
        this.noticeCooldown = cooldown;
    }

    onEnterWater() {
        this.timeInWater = 0;
        this.warned = false;
        this.panicWarned = false;
        this.danger = 0;
        this.rollTimer = 0;
        this.beepTimer = 0;

        if (this.cooldown > 0) {
            this.stalking = false;
            this.safeThisEntry = true;
            return;
        }

        const entryChance = (typeof this.config.entryChance === 'number') ? this.config.entryChance : 0.35;
        this.stalking = Math.random() < entryChance;
        this.safeThisEntry = !this.stalking;

        if (this.safeThisEntry) {
            this.maybeNotify("The water seems calm... for now.", 0.12, 6.0);
        }
    }

    onExitWater() {
        setWaterWarning(null);

        if (this.attack) return;

        if (this.stalking) {
            if (this.panicWarned) {
                this.maybeNotify("You made it across... lucky.", 0.9, 4.0);
            } else if (this.warned) {
                this.maybeNotify("You escape the ripples.", 0.6, 4.0);
            }
            this.cooldown = Math.max(this.cooldown, (typeof this.config.cooldown === 'number' ? this.config.cooldown : 10) * 0.25);
        } else if (this.safeThisEntry && this.timeInWater > 5) {
            this.maybeNotify("Clean crossing. No teeth today.", 0.15, 7.0);
        }

        this.timeInWater = 0;
        this.warned = false;
        this.panicWarned = false;
        this.stalking = false;
        this.safeThisEntry = false;
        this.danger = 0;
        this.rollTimer = 0;
        this.beepTimer = 0;
    }

    startAttack(target) {
        if (!target) return;
        let x = target.x, y = target.y;
        let found = false;

        for (let i = 0; i < 12; i++) {
            const a = rand(0, Math.PI * 2);
            const dist = rand(650, 1100);
            const tx = clamp(target.x + Math.cos(a) * dist, 200, CONFIG.mapWidth - 200);
            const ty = clamp(target.y + Math.sin(a) * dist, 200, CONFIG.mapHeight - 200);
            if (isWaterTile(getTileAtWorld(tx, ty))) {
                x = tx; y = ty; found = true; break;
            }
        }

        if (!found) {
            // As a fallback, attack from the target's current water position.
            x = target.x; y = target.y;
        }

        this.attack = { x, y, r: 75, life: 3.0, target: target };
        this.cooldown = typeof this.config.cooldown === 'number' ? this.config.cooldown : 10;
        
        if (target === player) {
            this.timeInWater = 0;
            this.warned = false;
            this.panicWarned = true;
            showNotification("MOSASAUR! GET OUT OF THE WATER!");
            AudioSys.playTone(60, 'sawtooth', 0.4, 0.12, 'mosa_warn');
        } else {
             // AI Attack - no global warning, maybe a sound?
             // Reset cooldown but don't reset player tracking state fully
        }
    }

    update(dt, player) {
        this.t += dt * 2.0;
        if (this.cooldown > 0) this.cooldown -= dt;
        if (this.noticeCooldown > 0) this.noticeCooldown -= dt;

        const inWater = isWaterTile(getTileAtWorld(player.x, player.y));

        if (inWater && !this.inWaterPrev) this.onEnterWater();
        if (!inWater && this.inWaterPrev) this.onExitWater();
        this.inWaterPrev = inWater;

        if (this.attack) {
            const a = this.attack;
            const target = a.target || player;
            const speed = typeof this.config.speed === 'number' ? this.config.speed : 1100;
            const dx = target.x - a.x;
            const dy = target.y - a.y;
            const dist = Math.hypot(dx, dy) || 1;

            a.x += (dx / dist) * speed * dt;
            a.y += (dy / dist) * speed * dt;
            a.life -= dt * (isWaterTile(getTileAtWorld(target.x, target.y)) ? 1 : 2.0);

            if (dist < target.r + a.r) {
                const biteMult = typeof this.config.biteDamageMult === 'number' ? this.config.biteDamageMult : 1.2;
                const damage = Math.max(1, target.maxHealth * biteMult);
                target.takeDamage(damage, this.source, 'mosa');
                
                if (!target.dead) {
                    if (target === player) {
                        target.invulnerableTimer = Math.max(target.invulnerableTimer, 1.25);
                        this.maybeNotify("You barely escape the Mosasaur!", 1.0, 4.0);
                    }
                    const ang = Math.atan2(target.y - a.y, target.x - a.x);
                    target.vx += Math.cos(ang) * 1100;
                    target.vy += Math.sin(ang) * 1100;
                    for (let i = 0; i < 18; i++) particles.push(new Particle(target.x, target.y, '#66ddff'));
                }
                a.life = 0;
            }

            if (target === player && isWaterTile(getTileAtWorld(player.x, player.y))) {
                 setWaterWarning("MOSASAUR ATTACKING!", '#ff4d6d');
            } else {
                 setWaterWarning(null);
            }

            if (a.life <= 0) {
                this.attack = null;
                setWaterWarning(null);
                if (target === player) this.onExitWater();
            }
            return;
        }

        if (!inWater) setWaterWarning(null);
        
        // Cooldown blocks all attacks
        if (this.cooldown > 0) return;

        // --- TRACKING LOGIC ---
        // We track the player for HUD warnings, but we scan for ANY target for attacks
        
        if (inWater) {
             this.timeInWater += dt;
             
             // Stalking Logic (Player Only for now)
             if (!this.stalking) {
                const lingerTime = typeof this.config.lingerTime === 'number' ? this.config.lingerTime : 12;
                const lingerChance = typeof this.config.lingerChancePerSecond === 'number' ? this.config.lingerChancePerSecond : 0.08;

                if (this.timeInWater > lingerTime && Math.random() < (lingerChance * dt)) {
                    this.stalking = true;
                    this.safeThisEntry = false;
                    this.warned = false;
                    this.panicWarned = false;
                    this.rollTimer = 0;
                    this.beepTimer = 0;
                    this.maybeNotify("The water stirs...", 1.0, 4.0);
                }
             }

             // Warnings (Player Only)
             const warningTime = typeof this.config.warningTime === 'number' ? this.config.warningTime : 4;
             const attackTime = typeof this.config.attackTime === 'number' ? this.config.attackTime : 9;
             const denom = Math.max(0.001, attackTime - warningTime);
             const rawDanger = (this.timeInWater - warningTime) / denom;
             this.danger = clamp(rawDanger, 0, 1);

             this.shadowAngle += dt * (0.7 + this.danger * 1.1);
             const shadowDist = 420 - this.danger * 260;
             this.shadowX = player.x + Math.cos(this.shadowAngle) * shadowDist;
             this.shadowY = player.y + Math.sin(this.shadowAngle) * shadowDist;
             if (!isWaterTile(getTileAtWorld(this.shadowX, this.shadowY))) {
                this.shadowX = player.x;
                this.shadowY = player.y;
             }

             if (!this.warned && this.timeInWater > warningTime) {
                this.warned = true;
                this.maybeNotify("Ripples... something huge is nearby.", 1.0, 3.0);
                AudioSys.playTone(120, 'sine', 0.15, 0.08, 'mosa_ripple');
             }
             if (!this.panicWarned && this.danger > 0.85) {
                this.panicWarned = true;
                this.maybeNotify("LEAVE THE WATER NOW!", 1.0, 2.5);
                AudioSys.playTone(220, 'square', 0.2, 0.12, 'mosa_panic');
                AudioSys.playTone(110, 'square', 0.25, 0.12, 'mosa_panic2');
             }

             if (this.danger <= 0.01 && this.timeInWater < warningTime) setWaterWarning("MOSASAUR THREAT: LOW", '#ffd37a');
             else if (this.danger < 0.6) setWaterWarning("MOSASAUR THREAT: MEDIUM", '#ffb703');
             else setWaterWarning("MOSASAUR THREAT: HIGH â€” LEAVE WATER!", '#ff4d6d');

             if (this.warned) {
                this.beepTimer -= dt;
                if (this.beepTimer <= 0) {
                    const interval = clamp(1.15 - this.danger * 0.9, 0.22, 1.15);
                    const freq = 140 + this.danger * 260;
                    const vol = 0.035 + this.danger * 0.06;
                    AudioSys.playTone(freq, 'sine', 0.06, vol, 'mosa_beep');
                    this.beepTimer = interval;
                }
             }
        }

        // --- ATTACK TRIGGER ---
        // Indiscriminate attack logic: Check ALL valid targets
        
        const attackTime = typeof this.config.attackTime === 'number' ? this.config.attackTime : 9;
        
        // Only attack if player is "Hot" OR if we roll for random aggression against AI
        // Simplify: We roll aggression constantly. If player is hot, they are a candidate.
        // If AI is in water, they are a candidate.
        
        this.rollTimer -= dt;
        if (this.rollTimer <= 0) {
            const rollInterval = typeof this.config.rollInterval === 'number' ? this.config.rollInterval : 1.0;
            const baseChance = typeof this.config.attackChancePerSecond === 'number' ? this.config.attackChancePerSecond : 0.25;
            
            // Calculate chance (boost if player is hot)
            let chance = baseChance;
            if (inWater && this.timeInWater > attackTime) {
                const ramp = typeof this.config.attackChanceRamp === 'number' ? this.config.attackChanceRamp : 0.06;
                chance += (this.timeInWater - attackTime) * ramp;
            }
            const maxChance = typeof this.config.attackMaxChance === 'number' ? this.config.attackMaxChance : 0.85;
            chance = clamp(chance, 0, maxChance);
            
            if (Math.random() < chance) {
                // Pick a target
                const candidates = [];
                if (inWater && this.timeInWater > attackTime) candidates.push(player);
                
                // Add AI Dinos in water
                for(let e of entities) {
                    if (e instanceof Dino && !e.isPlayer && !e.isBoss && !e.dead) {
                        if (isWaterTile(getTileAtWorld(e.x, e.y))) {
                            candidates.push(e);
                        }
                    }
                }
                
                if (candidates.length > 0) {
                    const victim = candidates[Math.floor(Math.random() * candidates.length)];
                    this.startAttack(victim);
                    return;
                }
            }
            this.rollTimer = rollInterval;
        }
    }

    draw(ctx, viewX, viewY, viewW, viewH, player) {
        if (!player) return;

        const inView = (x, y, r) => (
            x + r > viewX &&
            x - r < viewX + viewW &&
            y + r > viewY &&
            y - r < viewY + viewH
        );

        const drawRipples = (x, y, intensity = 1) => {
            const base = 18 + Math.sin(this.t * 2.2) * 4;
            for (let i = 0; i < 4; i++) {
                const rr = base + i * 20;
                const a = 0.10 * intensity * (1 - i * 0.12);
                ctx.strokeStyle = `rgba(200, 255, 255, ${a})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, rr, 0, Math.PI * 2);
                ctx.stroke();
            }
        };

        if (this.attack) {
            const a = this.attack;
            if (!inView(a.x, a.y, a.r + 60)) return;

            drawRipples(a.x, a.y, 1.6);
            ctx.save();
            ctx.translate(a.x, a.y);
            
            if (mosasaurusImage.complete && mosasaurusImage.naturalWidth > 0) {
                 const frameW = 256;
                 const frameH = 256;
                 const frame = Math.floor(Date.now() / 150) % 4;
                 const row = 2; // Attack row
                 
                 // Face player
                 if (player && player.x < a.x) ctx.scale(-1, 1);
                 
                 const drawH = a.r * 3.5;
                 const drawW = drawH * (frameW / frameH);
                 
                 ctx.shadowBlur = 25;
                 ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
                 
                 ctx.drawImage(mosasaurusImage, frame * frameW, row * frameH, frameW, frameH, -drawW * 0.55, -drawH/2, drawW, drawH);
            } else {
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
                ctx.fillStyle = 'rgba(0, 120, 140, 0.9)';
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(0, 0, a.r * 1.1, a.r * 0.55, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Fin
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0, 180, 200, 0.9)';
                ctx.beginPath();
                ctx.moveTo(-a.r * 0.2, 0);
                ctx.lineTo(0, -a.r * 0.9);
                ctx.lineTo(a.r * 0.2, 0);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
            return;
        }

        if (this.stalking && isWaterTile(getTileAtWorld(player.x, player.y))) {
            const shadowStart = (typeof this.config.warningTime === 'number' ? this.config.warningTime : 4) * 0.6;
            if (this.timeInWater > shadowStart && inView(this.shadowX, this.shadowY, 220)) {
                const alpha = 0.12 + this.danger * 0.22;
                ctx.save();
                ctx.translate(this.shadowX, this.shadowY);
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 70 + this.danger * 95, 34 + this.danger * 55, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            const rippleIntensity = 0.7 + this.danger * 1.2;
            if (inView(player.x, player.y, 160)) drawRipples(player.x, player.y, rippleIntensity);

            // Final cue: red ring at very high danger
            if (this.danger > 0.85 && inView(player.x, player.y, 200)) {
                ctx.strokeStyle = `rgba(255, 60, 100, ${0.18 + Math.sin(this.t * 4) * 0.06})`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 120 + Math.sin(this.t * 5) * 10, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    }
}

function handlePlayerDeath(killer) {
   respawnTimer = 3;
   const killerName = killer ? (killer.name || killer.className || 'Unknown') : 'Bad Luck';

   runState.lives = Math.max(0, runState.lives - 1);
   updateHud();

   document.getElementById('game-over-ui').style.display = 'block';

   if (runState.lives > 0) {
       document.getElementById('respawn-text').innerText = `Life lost. ${runState.lives}/${RUN_CONFIG.maxLives} remaining. Respawning...`;
   } else {
       runResetTimer = 4.0;
       respawnTimer = runResetTimer;
       document.getElementById('respawn-text').innerText = "Out of lives. Restarting run...";
       setObjectiveText('');
   }

   document.getElementById('ai-death-message').innerText = "âœ¨ Analyzing defeat...";
   AudioSys.playDeathSound();
   getDeathMessage({level: player.level, score: Math.floor(player.score), killer: killerName});
}

function refundStats() {
    if (player.dead) return;
    
    // 1. Refund Stat Points
    let totalPoints = 0;
    for (let i = 0; i < 9; i++) {
        totalPoints += player.stats[i];
        player.stats[i] = 0;
    }
    player.points += totalPoints;

    // 2. Reset Class & Mutations
    const species = player.className;
    player.classDef = CLASS_DEFS[species] || CLASS_DEFS['Baby Dino'];
    player.tier = player.classDef.tier || 0;
    player.scaleMult = player.classDef.scale || 1.0;
    
    // Reset Guns to Starter
    player.guns = JSON.parse(JSON.stringify(player.classDef.guns));
    
    // Clear Mutation Flags
    player.bonusGunCount = 0;
    player.weaponSizeMult = 1.0;
    player.fireRateMult = 1.0;
    player.hasTesla = false;
    player.teslaPower = 0;
    player.orbitals = [];
    player.activeEffects = []; // Clear temp effects too just in case
    
    // Clear History
    player.upgradesTaken = [];

    // 3. Recalculate & UI
    player.recalcStats();
    updateUpgradeUi();
    checkWeaponUpgrades(); // Re-trigger weapon upgrades if any
    
    showNotification("Full Respec Complete!");
}

function saveGame(silent = false) {
    if (player.dead) return;
    const data = {
        level: player.level,
        xp: player.xp,
        score: player.score,
        points: player.points,
        stats: player.stats,
        className: player.className,
        tier: player.tier,
        guns: player.guns,
        scaleMult: player.scaleMult,
        bonusGunCount: player.bonusGunCount,
        weaponSizeMult: player.weaponSizeMult,
        fireRateMult: player.fireRateMult,
        hasTesla: player.hasTesla,
        teslaPower: player.teslaPower,
        orbitalCount: player.orbitals.length,
        upgradesTaken: player.upgradesTaken
    };
    localStorage.setItem('dino_io_save', JSON.stringify(data));
    if (!silent) showNotification("Game Saved");
}

function loadGame() {
    const json = localStorage.getItem('dino_io_save');
    if (!json) return;
    
    try {
        const data = JSON.parse(json);
        player.level = data.level;
        player.xp = data.xp;
        player.score = data.score;
        player.points = data.points;
        player.stats = data.stats;
        player.className = data.className;
        player.tier = data.tier;
        player.guns = data.guns;
        player.scaleMult = data.scaleMult;
        
        player.bonusGunCount = data.bonusGunCount || 0;
        player.weaponSizeMult = data.weaponSizeMult || 1.0;
        player.fireRateMult = data.fireRateMult || 1.0;
        player.hasTesla = data.hasTesla || false;
        player.teslaPower = data.teslaPower || 0;
        player.upgradesTaken = data.upgradesTaken || [];
        
        if (data.orbitalCount) {
             for(let i=0; i<data.orbitalCount; i++) {
                 player.orbitals.push({angle: (Math.PI*2/data.orbitalCount)*i, r: 15, dist: 0}); 
             }
        }
        
        player.classDef = CLASS_DEFS[player.className] || CLASS_DEFS['Baby Dino'];
        
        player.recalcStats();
        updateUpgradeUi();
        updateHud();
        showNotification(`Welcome back, Lvl ${player.level} ${player.className}!`);
    } catch(e) {
        console.error("Save file corrupted", e);
    }
}

// --- TERRAIN SYSTEM ---
const TILES = { DIRT: 0, GRASS: 1, WATER: 2, LAVA: 3, ICE: 4, FROZEN_LAVA: 5 };
const TILE_COLORS = ['#2d241b', '#0b400b', '#002b36', '#401a1a', '#aaddff', '#88aabb']; 
let terrainGrid = [];
const terrainImage = new Image();
const babyDinoImage = new Image();
const raptorImage = new Image();
const dilophosaurImage = new Image();
const stegosaurusImage = new Image(); // Using Ankylosaurus sprite
const pterodactylImage = new Image(); // Using Quetzalcoatlus sprite
const triceratopsImage = new Image();
const giganotosaurusImage = new Image(); // Using Distortus Rex sprite
const spinosaurusImage = new Image();
const archaeopteryxImage = new Image(); // Using Aquilops sprite
const titanosaurImage = new Image();
const indominusImage = new Image();
const trexImage = new Image();
const velociraptorImage = new Image(); // Using Raptor sprite
const mosasaurusImage = new Image();

babyDinoImage.src = 'spritesheets/babyDino.png';
raptorImage.src = 'spritesheets/raptor.png';
dilophosaurImage.src = 'spritesheets/dilophosaurus.png';
stegosaurusImage.src = 'spritesheets/anklyosaurus.png';
pterodactylImage.src = 'spritesheets/Quetzalcoatlus.png';
triceratopsImage.src = 'spritesheets/triceratops.png';
giganotosaurusImage.src = 'spritesheets/distortusRex.png';
spinosaurusImage.src = 'spritesheets/spinosaurus.png';
archaeopteryxImage.src = 'spritesheets/aquilops.png';
titanosaurImage.src = 'spritesheets/titanosaurus.png';
indominusImage.src = 'spritesheets/indominousRex.png';
trexImage.src = 'spritesheets/trex.png';
velociraptorImage.src = 'spritesheets/raptor.png';
mosasaurusImage.src = 'spritesheets/mosasaurus.png';
const lootImage = new Image();
lootImage.src = 'spritesheets/loot.png';
const projectileImage = new Image();
projectileImage.src = 'spritesheets/projectiles.png';
const iconImage = new Image();
iconImage.src = 'spritesheets/icons.png';

function generateMap() {
    const cols = CONFIG.mapWidth / CONFIG.gridSize;
    const rows = CONFIG.mapHeight / CONFIG.gridSize;
    terrainGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(TILES.DIRT));

    if (currentStageDef && currentStageDef.terrainSrc && terrainImage.src.indexOf(currentStageDef.terrainSrc) === -1) {
        terrainImage.src = currentStageDef.terrainSrc;
    }

    const drawBlob = (type, count, minR, maxR) => {
        for(let i=0; i<count; i++) {
            const cx = Math.floor(rand(0, cols));
            const cy = Math.floor(rand(0, rows));
            const r = Math.floor(rand(minR, maxR));
            
            for(let x = cx - r; x <= cx + r; x++) {
                for(let y = cy - r; y <= cy + r; y++) {
                    if (x >= 0 && x < cols && y >= 0 && y < rows) {
                        const d = Math.hypot(x - cx, y - cy);
                        if (d < r) terrainGrid[x][y] = type;
                    }
                }
            }
        }
    };

    const stageTerrain = (currentStageDef && currentStageDef.terrain) ? currentStageDef.terrain : STAGE_DEFS[0].terrain;

    // Determine Tile Types based on Level
    let waterType = TILES.WATER;
    let lavaType = TILES.LAVA;
    
    if (currentStageDef && currentStageDef.name === 'Level 2') {
        waterType = TILES.ICE;
        lavaType = TILES.FROZEN_LAVA;
    }

    drawBlob(TILES.GRASS, stageTerrain.grass.count, stageTerrain.grass.minR, stageTerrain.grass.maxR);
    drawBlob(waterType, stageTerrain.waterSmall.count, stageTerrain.waterSmall.minR, stageTerrain.waterSmall.maxR);
    drawBlob(waterType, stageTerrain.waterBig.count, stageTerrain.waterBig.minR, stageTerrain.waterBig.maxR);
    drawBlob(lavaType, stageTerrain.lava.count, stageTerrain.lava.minR, stageTerrain.lava.maxR);
}

function drawTerrain(ctx, viewX, viewY, viewW, viewH) {
    const startX = Math.max(0, Math.floor(viewX / CONFIG.gridSize));
    const startY = Math.max(0, Math.floor(viewY / CONFIG.gridSize));
    const endX = Math.min(CONFIG.mapWidth / CONFIG.gridSize, Math.ceil((viewX + viewW) / CONFIG.gridSize));
    const endY = Math.min(CONFIG.mapHeight / CONFIG.gridSize, Math.ceil((viewY + viewH) / CONFIG.gridSize));

    const useImage = terrainImage.complete && terrainImage.naturalWidth > 0;
    const tW = useImage ? terrainImage.naturalWidth / 2 : 0;
    const tH = useImage ? terrainImage.naturalHeight / 2 : 0;

    for (let x = startX; x < endX; x++) {
        for (let y = startY; y < endY; y++) {
            const t = terrainGrid[x][y];
            const posX = x * CONFIG.gridSize;
            const posY = y * CONFIG.gridSize;
            
            if (useImage) {
                // Mapping:
                // Grass (1): Top-Left (0,0)
                // Dirt (0): Top-Right (1,0)
                // Water (2) / Ice (4): Bottom-Left (0,1)
                // Lava (3) / Frozen Lava (5): Bottom-Right (1,1)
                
                let sx = 0, sy = 0;
                if (t === TILES.DIRT) { sx = tW; sy = 0; }
                else if (t === TILES.GRASS) { sx = 0; sy = 0; }
                else if (t === TILES.WATER || t === TILES.ICE) { sx = 0; sy = tH; }
                else if (t === TILES.LAVA || t === TILES.FROZEN_LAVA) { sx = tW; sy = tH; }
                
                // Draw slightly overlapping to prevent bleeding lines
                ctx.drawImage(terrainImage, sx, sy, tW, tH, posX, posY, CONFIG.gridSize + 1, CONFIG.gridSize + 1);
            } else {
                ctx.fillStyle = TILE_COLORS[t] || '#222';
                ctx.fillRect(posX, posY, CONFIG.gridSize + 1, CONFIG.gridSize + 1);
            }
            
            // Texture detail overlays (bubbles/sparks)
            if (t === TILES.WATER) {
                 if ((x+y + Math.floor(Date.now()/500)) % 7 === 0) {
                     ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                     ctx.beginPath();
                     ctx.arc(posX + CONFIG.gridSize/2, posY + CONFIG.gridSize/2, 5 + Math.sin(Date.now()*0.005)*2, 0, Math.PI*2);
                     ctx.fill();
                 }
            } else if (t === TILES.LAVA && Math.random() < 0.02) {
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(posX + rand(10,90), posY + rand(10,90), 4, 4);
            } else if (t === TILES.ICE || t === TILES.FROZEN_LAVA) {
                 // Sparkle for ice
                 if (Math.random() < 0.005) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fillRect(posX + rand(5,95), posY + rand(5,95), 3, 3);
                 }
            }
        }
    }
}

function getStageDef(stageIndex) {
    const idx = Math.max(0, Math.min(STAGE_DEFS.length - 1, stageIndex));
    return STAGE_DEFS[idx];
}

function getTileAtWorld(x, y) {
    const tx = Math.floor(x / CONFIG.gridSize);
    const ty = Math.floor(y / CONFIG.gridSize);
    if (!terrainGrid || !terrainGrid[tx] || terrainGrid[tx][ty] === undefined) return null;
    return terrainGrid[tx][ty];
}

function isLandTile(tile) {
    return tile !== null && tile !== TILES.WATER && tile !== TILES.LAVA;
}

function isWaterTile(tile) {
    return tile === TILES.WATER;
}

function findWorldPosition({ tileOk, margin = 200, maxAttempts = 250, avoid = [] }) {
    for (let i = 0; i < maxAttempts; i++) {
        const x = rand(margin, CONFIG.mapWidth - margin);
        const y = rand(margin, CONFIG.mapHeight - margin);
        const tile = getTileAtWorld(x, y);
        if (!tileOk(tile)) continue;

        let ok = true;
        for (const a of avoid) {
            const minD = a.minDist || 0;
            const d = Math.hypot(x - a.x, y - a.y);
            if (d < minD) { ok = false; break; }
        }
        if (!ok) continue;

        return { x, y };
    }
    return { x: CONFIG.mapWidth / 2, y: CONFIG.mapHeight / 2 };
}

function hideOverlays() {
    document.getElementById('game-over-ui').style.display = 'none';
    document.getElementById('reward-overlay').style.display = 'none';
    document.getElementById('run-complete-ui').style.display = 'none';
}

function setObjectiveText(text) {
    const el = document.getElementById('objective-text');
    if (!el) return;
    el.innerText = text || '';
}

function setWaterWarning(text, color = null) {
    const el = document.getElementById('water-warning');
    if (!el) return;
    if (!text) {
        el.style.display = 'none';
        el.innerText = '';
        return;
    }
    el.style.display = 'block';
    el.innerText = text;
    if (color) el.style.color = color;
}

function createStageState(stageIndex) {
    const def = getStageDef(stageIndex);
    return {
        def,
        jewelTotal: def.jewelTotal,
        jewelsCollected: 0,
        jewels: [],
        gate: null,
        artifact: null,
        bossSpawned: false,
        bossDefeated: false,
        mosasaur: def.mosasaur ? new MosasaurThreat(def.mosasaur) : null,
    };
}

function spawnStageObjectives() {
    if (!stageState) return;

    stageState.jewels.length = 0;
    stageState.jewelsCollected = 0;
    stageState.gate = null;
    stageState.artifact = null;
    stageState.bossSpawned = false;
    stageState.bossDefeated = false;

    const stageDef = stageState.def;
    const avoid = [{ x: runState.spawnX, y: runState.spawnY, minDist: 900 }];

    const waterJewelCount = Math.max(0, Math.min(stageDef.waterJewelCount || 0, stageDef.jewelTotal));
    const waterJewelIndices = new Set();
    while (waterJewelIndices.size < waterJewelCount) {
        waterJewelIndices.add(Math.floor(rand(0, stageDef.jewelTotal)));
    }

    for (let i = 0; i < stageDef.jewelTotal; i++) {
        const jewelType = JEWEL_TYPES[i % JEWEL_TYPES.length];
        const isWater = waterJewelIndices.has(i);
        const pos = findWorldPosition({
            tileOk: (t) => isWater ? isWaterTile(t) : isLandTile(t),
            margin: 250,
            maxAttempts: 500,
            avoid,
        });
        const jewel = new JewelObjective(jewelType, pos.x, pos.y);
        stageState.jewels.push(jewel);
        avoid.push({ x: pos.x, y: pos.y, minDist: 700 });
    }

    const gatePos = findWorldPosition({
        tileOk: (t) => isLandTile(t),
        margin: 300,
        maxAttempts: 500,
        avoid: [...avoid, { x: runState.spawnX, y: runState.spawnY, minDist: 2200 }],
    });
    stageState.gate = new GateObjective(gatePos.x, gatePos.y);
}

function startRun() {
    runState.stageIndex = 0;
    runState.lives = RUN_CONFIG.maxLives;
    runState.score = 0;
    runState.selectedSpecies = 'Baby Dino';
    startStage(0, runState.selectedSpecies);
}

function startStage(stageIndex, species) {
    hideOverlays();
    document.getElementById('class-upgrade-menu').innerHTML = '';
    document.getElementById('reward-menu').innerHTML = '';
    setWaterWarning(null);
    
    // Audio Management
    if (stageIndex === 0) {
        AudioSys.resumeNormalMusic();
    } else if (AudioSys.victoryMusic && AudioSys.victoryMusic.paused) {
        AudioSys.resumeNormalMusic();
    }

    const stageDef = getStageDef(stageIndex);
    currentStageDef = stageDef;
    runState.stageIndex = stageIndex;
    runState.selectedSpecies = species;

    boss = null;
    bossArena = null;
    respawnTimer = 3;
    runResetTimer = 0;
    gameMode = 'play';

    entities = [];
    powerUps = [];
    particles = [];
    damageNumbers = [];
    explosions = [];

    stageState = createStageState(stageIndex);

    generateMap();

    const spawn = findWorldPosition({
        tileOk: (t) => isLandTile(t),
        margin: 350,
        maxAttempts: 600,
        avoid: [],
    });
    runState.spawnX = spawn.x;
    runState.spawnY = spawn.y;

    player = new Dino(runState.spawnX, runState.spawnY, true);
    player.name = "You";
    player.evolve(species);
    player.score = runState.score;
    player.recalcStats();
    player.health = player.maxHealth;
    const startInvuln = stageDef.spawn?.startInvulnerable || 0;
    if (startInvuln > 0) player.invulnerableTimer = startInvuln;
    entities.push(player);

    // Baseline world population (kept lighter than endless mode)
    const initialShapes = stageDef.spawn?.initialShapes ?? 500;
    const initialPowerUps = stageDef.spawn?.initialPowerUps ?? 14;
    const initialEnemies = stageDef.spawn?.initialEnemies ?? (8 + stageIndex * 2);
    for (let i = 0; i < initialShapes; i++) spawnShape();
    for (let i = 0; i < initialPowerUps; i++) spawnPowerUp();
    for (let i = 0; i < initialEnemies; i++) spawnEnemy();

    spawnStageObjectives();
    setObjectiveText(`Collect ${stageState.jewelTotal} jewels to unlock the gate.`);
    updateHud();
}

function getDifficultyLevel() {
    const base = player ? player.level : 1;
    const offset = (stageState && stageState.def && typeof stageState.def.difficultyOffset === 'number') ? stageState.def.difficultyOffset : 0;
    return base + offset;
}

function updateStageObjectives(dt) {
    if (!stageState || !player || player.dead) return;

    // Jewels
    for (let i = stageState.jewels.length - 1; i >= 0; i--) {
        const jewel = stageState.jewels[i];
        jewel.update(dt);
        const d = Math.hypot(player.x - jewel.x, player.y - jewel.y);
        if (d < player.r + jewel.r) {
            stageState.jewels.splice(i, 1);
            stageState.jewelsCollected++;
            showNotification(`Collected ${jewel.jewelType.name}! (${stageState.jewelsCollected}/${stageState.jewelTotal})`);
            AudioSys.playTone(880, 'sine', 0.12, 0.1, 'jewel');
            updateHud();

            if (stageState.jewelsCollected >= stageState.jewelTotal && stageState.gate && !stageState.gate.unlocked) {
                stageState.gate.unlocked = true;
                showNotification("Gate Unlocked!");
                setObjectiveText("Find the gate and touch it.");
            }
        }
    }

    // Gate
    const gate = stageState.gate;
    if (gate) {
        gate.update(dt);
        const d = Math.hypot(player.x - gate.x, player.y - gate.y);
        if (d < player.r + gate.r * 0.55) {
            if (!gate.unlocked) {
                if (gate.hintCooldown <= 0) {
                    showNotification(`Gate Locked (${stageState.jewelsCollected}/${stageState.jewelTotal})`);
                    gate.hintCooldown = 2.5;
                }
            } else if (stageState.bossSpawned && boss && !boss.dead) {
                if (gate.hintCooldown <= 0) {
                    showNotification("The boss is already awake â€” follow the purple marker on the minimap!");
                    gate.hintCooldown = 3.0;
                }
            } else if (!gate.artifactRevealed && !stageState.artifact) {
                gate.artifactRevealed = true;
                stageState.artifact = new BossArtifactObjective(gate.x, gate.y - gate.r * 0.35);
                showNotification("An ancient artifact has been revealed!");
                setObjectiveText("Touch the artifact to awaken the boss.");
            }
        }
    }

    // Artifact
    if (stageState.artifact) {
        stageState.artifact.update(dt);
        const d = Math.hypot(player.x - stageState.artifact.x, player.y - stageState.artifact.y);
        if (d < player.r + stageState.artifact.r) {
            stageState.artifact = null;
            spawnBossForStage();
        }
    }
}

function spawnBossForStage() {
    if (!stageState || stageState.bossSpawned) return;

    const avoid = [{ x: player.x, y: player.y, minDist: 1600 }];
    if (stageState.gate) avoid.push({ x: stageState.gate.x, y: stageState.gate.y, minDist: 900 });

    const bossPos = findWorldPosition({
        tileOk: (t) => isLandTile(t),
        margin: 350,
        maxAttempts: 800,
        avoid,
    });

    stageState.bossSpawned = true;
    setObjectiveText("Boss awakened! Follow the purple marker on the minimap and defeat it.");
    showNotification("Boss marked on minimap!");

    // Clear ambient enemies to focus the fight
    entities = entities.filter(e => !(e instanceof Dino && !e.isPlayer && !e.isBoss));

    spawnBoss(bossPos.x, bossPos.y);
}

function showSpeciesRewardMenu(nextSpeciesOptions) {
    const overlay = document.getElementById('reward-overlay');
    const menu = document.getElementById('reward-menu');
    const subtitle = document.getElementById('reward-subtitle');

    menu.innerHTML = '';
    overlay.style.display = 'flex';
    if (subtitle) subtitle.innerText = `Choose your species for ${getStageDef(runState.stageIndex + 1).name}.`;

    // Pixel-perfect sprite centering for 800x400 sheet (Ratio 2.0)
    const size = 64;
    const ratio = 2.0;
    const bgH = size * 4;
    const bgW = bgH * ratio;
    const cellW = bgW / 4;
    const centerOffX = (cellW - size) / 2;

    nextSpeciesOptions.forEach(species => {
        const def = CLASS_DEFS[species];
        if (!def) return;

        const card = document.createElement('div');
        card.className = 'class-card';

        const label = def.label || species;
        let iconRow = 3, iconCol = 3;
        if (label.includes('Twin') || label.includes('Triple') || label.includes('Octo')) { iconRow = 2; iconCol = 1; }
        else if (label.includes('Rail') || label.includes('Beam') || label.includes('Sniper')) { iconRow = 2; iconCol = 2; }
        else if (label.includes('Flame') || label.includes('Inferno') || label.includes('Hydra')) { iconRow = 2; iconCol = 3; }
        else if (label.includes('Launcher') || label.includes('Cluster') || label.includes('Nuke') || label.includes('Czar')) { iconRow = 3; iconCol = 0; }

        const offX = - (iconCol * cellW) - centerOffX;
        const offY = - (iconRow * size);

        card.innerHTML = `<div class="class-card-icon" style="background-size: ${bgW}px ${bgH}px; background-position: ${offX}px ${offY}px"></div><div class="class-card-title">${species}</div><div class="class-card-desc">${label}</div>`;

        card.onclick = () => {
            overlay.style.display = 'none';
            menu.innerHTML = '';
            gameMode = 'play';
            startStage(runState.stageIndex + 1, species);
        };

        menu.appendChild(card);
    });
}

function handleBossDefeated() {
    if (!stageState || stageState.bossDefeated) return;

    stageState.bossDefeated = true;
    boss = null;
    bossArena = null;
    document.getElementById('boss-bar-container').style.display = 'none';
    
    // Play Victory Music (Boss music paused inside this method)
    AudioSys.playVictoryMusic();

    // Show Victory UI
    const victoryUi = document.getElementById('boss-slain-ui');
    if (victoryUi) {
        victoryUi.style.display = 'flex';
    }

    setObjectiveText('');

    // Delay transition
    setTimeout(() => {
        if (victoryUi) victoryUi.style.display = 'none';

        if (runState.stageIndex < RUN_CONFIG.totalStages - 1) {
            gameMode = 'reward';
            showSpeciesRewardMenu(stageState.def.nextSpeciesOptions || []);
            return;
        }

        gameMode = 'complete';
        const completeText = document.getElementById('run-complete-text');
        if (completeText) completeText.innerText = `You cleared all available levels. Score: ${Math.floor(runState.score)} â€¢ Lives left: ${runState.lives}/${RUN_CONFIG.maxLives}`;
        document.getElementById('run-complete-ui').style.display = 'block';
    }, 4000);
}

function drawStageObjectives(ctx, viewX, viewY, viewW, viewH) {
    if (!stageState) return;

    const inView = (o) => (
        o.x + o.r > viewX &&
        o.x - o.r < viewX + viewW &&
        o.y + o.r > viewY &&
        o.y - o.r < viewY + viewH
    );

    stageState.jewels.forEach(j => {
        if (inView(j)) j.draw(ctx);
    });
    if (stageState.gate && inView(stageState.gate)) stageState.gate.draw(ctx);
    if (stageState.artifact && inView(stageState.artifact)) stageState.artifact.draw(ctx);
    if (stageState.mosasaur) stageState.mosasaur.draw(ctx, viewX, viewY, viewW, viewH, player);
}

// Initialize
init();

function init() {
    resize();
    window.addEventListener('resize', resize);

    // Input listeners initiate Audio
    const startAudio = () => { 
        AudioSys.init(); 
        
        // "Bless" the audio element to unlock autoplay policy
        const silentPlay = AudioSys.deathAudio.play();
        if (silentPlay !== undefined) {
            silentPlay.then(() => {
                AudioSys.deathAudio.pause();
                AudioSys.deathAudio.currentTime = 0;
            }).catch(e => console.log("Audio unlock failed", e));
        }

        window.removeEventListener('keydown', startAudio); 
        window.removeEventListener('mousedown', startAudio); 
    };
    window.addEventListener('keydown', startAudio);
    window.addEventListener('mousedown', startAudio);

    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (e.key.length === 1) keys[e.key.toLowerCase()] = true;
        
        // Upgrade Stats: 1-9 (Standard Row or Numpad)
        if (e.key >= '1' && e.key <= '9') {
            upgradeStat(parseInt(e.key) - 1);
        } else if (e.code.startsWith('Numpad') && e.code.length === 7) {
            const num = parseInt(e.code[6]);
            if (num >= 1 && num <= 9) upgradeStat(num - 1);
        }

        if (e.key === 'm') document.getElementById('minimap-container').classList.toggle('hidden');

        // Debug: Shift + N to Skip Level
        if (e.key === 'N' && e.shiftKey) {
            if (runState.stageIndex < RUN_CONFIG.totalStages - 1) {
                startStage(runState.stageIndex + 1, player.className);
                showNotification("DEBUG: Skipped to Level " + (runState.stageIndex + 1));
            } else {
                showNotification("DEBUG: Last Level Reached");
            }
        }
        
        // Debug: Shift + B to Spawn Boss immediately
        if (e.key === 'B' && e.shiftKey) {
            spawnBossForStage();
             showNotification("DEBUG: Boss Spawner Triggered");
        }
    });
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
        if (e.key.length === 1) keys[e.key.toLowerCase()] = false;
    });
    
    window.addEventListener('blur', () => {
        for (let k in keys) keys[k] = false;
        mouse.down = false;
        if (AudioSys.bgMusic && !AudioSys.bgMusic.paused) {
            AudioSys.bgMusic.pause();
        }
    });

    window.addEventListener('focus', () => {
        if (player && !player.dead) {
            AudioSys.resumeMusic();
        }
    });
    
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        mouse.x = (e.clientX - rect.left) * scaleX;
        mouse.y = (e.clientY - rect.top) * scaleY;
    });
    
    canvas.addEventListener('mousedown', () => mouse.down = true);
    canvas.addEventListener('mouseup', () => mouse.down = false);

    setupTouch();
    setupUpgradeUI();

    startRun();
    requestAnimationFrame(gameLoop);
}

function resize() {
    // Cap internal resolution to ~1080p to prevent fill-rate lag on 4K/Retina screens
    const MAX_WIDTH = 1920;
    const scale = Math.min(1, MAX_WIDTH / window.innerWidth);
    
    canvas.width = window.innerWidth * scale;
    canvas.height = window.innerHeight * scale;
    
    width = canvas.width;
    height = canvas.height;
    
    // Enable high-quality smoothing for sprites
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    if (player) player.recalcStats();
}

function spawnShape() {
    let type = 'egg';
    const r = Math.random();
    
    let x, y;
    let valid = false;
    
    // Try to find valid terrain (not water/lava)
    for(let i=0; i<3; i++) {
        let isNest = false;
        if (Math.random() < 0.2) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * CONFIG.nestRadius;
            x = CONFIG.mapWidth/2 + Math.cos(angle)*dist;
            y = CONFIG.mapHeight/2 + Math.sin(angle)*dist;
            isNest = true;
        } else {
            x = rand(0, CONFIG.mapWidth);
            y = rand(0, CONFIG.mapHeight);
        }
        
        const tx = Math.floor(x / CONFIG.gridSize);
        const ty = Math.floor(y / CONFIG.gridSize);
        if (terrainGrid && terrainGrid[tx] && terrainGrid[tx][ty] !== undefined) {
             const t = terrainGrid[tx][ty];
             if (t !== TILES.WATER && t !== TILES.LAVA) {
                 valid = true;
                 break;
             }
        }
    }
    
    if (!valid) return;

    const globalScaling = Math.max(1, player.level / 20);
    const sizeVar = rand(0.8, 1.5) * globalScaling;

    if (r > 0.7) type = 'plant';
    if (r > 0.9) type = 'fossil';
    if (r > 0.98) type = 'meteor';
    
    // Nest overrides
    const distToCenter = Math.hypot(x - CONFIG.mapWidth/2, y - CONFIG.mapHeight/2);
    if (distToCenter < CONFIG.nestRadius) {
         type = 'fossil';
         if (Math.random() < 0.05) type = 'alpha_fossil';
    }

    const distToPlayer = Math.hypot(x - player.x, y - player.y);
    if (distToPlayer < 400) return;

    entities.push(new Shape(type, x, y, sizeVar));
}

function spawnEnemy() {
    let x = 0, y = 0;
    let valid = false;

    for (let attempt = 0; attempt < 10; attempt++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = rand(900, 1400);
        x = player.x + Math.cos(angle) * dist;
        y = player.y + Math.sin(angle) * dist;

        x = clamp(x, 120, CONFIG.mapWidth - 120);
        y = clamp(y, 120, CONFIG.mapHeight - 120);

        const tile = getTileAtWorld(x, y);
        if (isLandTile(tile)) { valid = true; break; }
    }

    if (!valid) return;

    // Pack Spawning Logic
    const isPack = Math.random() < 0.20; // 20% chance for a pack
    const count = isPack ? Math.floor(rand(3, 6)) : 1;
    
    // Determine species/level once for the whole pack
    const enemyCfg = stageState?.def?.enemy || {};
    const levelOffset = enemyCfg.levelOffset || 0;
    const baseLevel = (player?.level || 1) + levelOffset;
    const minLvl = Math.max(1, Math.floor(baseLevel + (enemyCfg.minDelta ?? -1)));
    const maxLvl = Math.max(minLvl, Math.floor(baseLevel + (enemyCfg.maxDelta ?? 1)));
    const packLevel = Math.floor(rand(minLvl, maxLvl + 1));

    // Pre-calculate species so they match
    // We create a temp dino just to resolve the species logic effectively, or we can just force it.
    // Easier way: Create first one, get its species, then force others.
    
    let packSpecies = null;

    for (let i = 0; i < count; i++) {
        let ex = x, ey = y;
        if (i > 0) {
            ex += rand(-150, 150);
            ey += rand(-150, 150);
            ex = clamp(ex, 120, CONFIG.mapWidth - 120);
            ey = clamp(ey, 120, CONFIG.mapHeight - 120);
        }

        const enemy = new Dino(ex, ey, false);
        enemy.level = packLevel;
        
        enemy.evolve("Baby Dino"); 
        
        if (i === 0) {
            enemy.assignAIClass();
            packSpecies = enemy.className;
        } else if (packSpecies) {
            enemy.evolve(packSpecies);
        }
        
        const traitChance = enemyCfg.traitChance ?? 0.35;
        if (Math.random() < traitChance) {
            const r = Math.random();
            if (r < 0.25) enemy.trait = 'armored';
            else if (r < 0.5) enemy.trait = 'evasive';
            else if (r < 0.75) enemy.trait = 'ablative';
            else enemy.trait = 'spiked';
        } else {
            enemy.trait = null;
        }

        const rangedChance = enemyCfg.rangedChance ?? 0.2;
        const isRanged = Math.random() < rangedChance;
        
        if (!isRanged) {
            enemy.behavior = 'melee';
            enemy.guns = []; 
        } else {
            enemy.behavior = 'ranged';
        }

        const statsDiv = enemyCfg.statsDiv ?? 3;
        for(let k=0; k<8; k++) enemy.stats[k] = rand(0, enemy.level / statsDiv);
        
        enemy.recalcStats();

        // Apply behavior + stage tuning after stat recompute
        if (!isRanged) {
            enemy.bodyDamage *= 1.25;
            enemy.moveSpeed *= 1.08;
        }

        const healthMult = enemyCfg.healthMult ?? 1.0;
        const damageMult = enemyCfg.damageMult ?? 1.0;
        const moveSpeedMult = enemyCfg.moveSpeedMult ?? 1.0;
        enemy.maxHealth *= healthMult;
        enemy.health = enemy.maxHealth;
        enemy.bodyDamage *= damageMult;
        enemy.bulletDmg *= damageMult;
        enemy.moveSpeed *= moveSpeedMult;

        entities.push(enemy);
    }
}

function spawnBoss(x, y) {
    if (boss && !boss.dead) return;
    
    const template = BOSS_TEMPLATES[Math.floor(Math.random() * BOSS_TEMPLATES.length)];

    const stageMult = 1 + runState.stageIndex * 0.65;
    const diffLevel = getDifficultyLevel();
    const levelMult = Math.max(1, diffLevel / 15);
    const powerMult = stageMult * levelMult;

    boss = new Dino(x, y, false);
    boss.isBoss = true;
    
    boss.name = template.name;
    boss.color = template.color;
    boss.trait = template.trait; 
    boss.guns = JSON.parse(JSON.stringify(template.guns)); 

    boss.r = 60 * template.scale * Math.min(3.5, 1 + runState.stageIndex * 0.35 + (diffLevel / 60)); 
    boss.maxHealth = 9000 * template.hpMult * powerMult;
    boss.health = boss.maxHealth;
    
    boss.bulletDmg = 10 * powerMult;
    boss.xpValue = 8000 * powerMult;

    bossArena = { x: boss.x, y: boss.y, r: 750 + runState.stageIndex * 150 };
    
    entities.push(boss);
    
    showNotification(`WARNING: ${boss.name} has awakened!`);
    const barContainer = document.getElementById('boss-bar-container');
    barContainer.style.display = 'block';
    document.getElementById('boss-name').innerText = boss.name.toUpperCase();
    
    AudioSys.playBossMusic();
}

function spawnPowerUp() {
    if (powerUps.length >= 30) return;

    const baseTypes = Object.keys(POWERUP_TYPES).filter(t => t !== 'life');
    const canSpawnLife = runState.lives < RUN_CONFIG.maxLives;
    const type = (canSpawnLife && Math.random() < 0.02)
        ? 'life'
        : baseTypes[Math.floor(Math.random() * baseTypes.length)];

    // Spawn somewhat near player on valid terrain (avoid water/lava)
    let x = 0, y = 0;
    let valid = false;

    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = rand(400, 1500);
        x = player.x + Math.cos(angle) * dist;
        y = player.y + Math.sin(angle) * dist;
        x = clamp(x, 120, CONFIG.mapWidth - 120);
        y = clamp(y, 120, CONFIG.mapHeight - 120);

        const tile = getTileAtWorld(x, y);
        if (isLandTile(tile)) { valid = true; break; }
    }

    if (!valid) return;
    powerUps.push(new PowerUp(x, y, type));
}

function createExplosion(x, y, damage, radius, source) {
    explosions.push(new ExplosionEffect(x, y, radius));
    AudioSys.explode();
    
    for(let i=0; i<15; i++) {
        particles.push(new Particle(x, y, '#ff4500'));
    }
    entities.forEach(e => {
        if (e.dead) return;
        const dist = Math.hypot(e.x - x, e.y - y);
        if (dist < radius) {
            const damageFactor = 1 - (dist / radius); 
            e.takeDamage(damage * damageFactor, source);
            const angle = Math.atan2(e.y - y, e.x - x);
            e.vx += Math.cos(angle) * 500 * damageFactor * e.pushability;
            e.vy += Math.sin(angle) * 500 * damageFactor * e.pushability;
        }
    });
}

function eatEntity(predator, prey) {
    if (prey instanceof Dino && prey.invulnerableTimer > 0) return;

    spawnDamageNumber(prey.x, prey.y, "CRUNCH!");
    AudioSys.crunch();
    
    prey.health = 0; 
    prey.dead = true;
    prey.onDeath(predator); 
    
    if (predator instanceof Dino) {
        predator.health = Math.min(predator.health + (prey.maxHealth * 0.2), predator.maxHealth);
        if (predator.isPlayer) {
            predator.gainXp(prey.xpValue || (prey.maxHealth / 2));
        }
    }
}

function setupTouch() {
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (!isTouch) return;
    document.getElementById('mobile-controls').style.display = 'block';
    
    const setupStick = (id, target) => {
        const stick = document.getElementById(id);
        const knob = stick.querySelector('.stick-knob');
        let startX, startY;
        stick.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0]; startX = t.clientX; startY = t.clientY;
            target.active = true;
        }, {passive:false});
        stick.addEventListener('touchmove', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            const dx = t.clientX - startX, dy = t.clientY - startY;
            const dist = Math.min(Math.hypot(dx,dy), 35);
            const angle = Math.atan2(dy, dx);
            const kx = Math.cos(angle)*dist, ky = Math.sin(angle)*dist;
            knob.style.transform = `translate(${kx}px, ${ky}px)`;
            target.x = kx/35; target.y = ky/35;
        }, {passive:false});
        stick.addEventListener('touchend', e => {
            knob.style.transform = `translate(0,0)`;
            target.active = false; target.x = 0; target.y = 0;
        });
    };
    setupStick('stick-left', joystickLeft);
    setupStick('stick-right', joystickRight);
}

const SnowSystem = {
    flakes: [],
    maxFlakes: 150,
    init: function() {
        console.log("SnowSystem Init");
        for(let i=0; i<this.maxFlakes; i++) {
            this.flakes.push(this.createFlake(true));
        }
    },
    createFlake: function(randomY=false) {
        const w = width || window.innerWidth;
        const h = height || window.innerHeight;
        return {
            x: Math.random() * w,
            y: randomY ? Math.random() * h : -10,
            r: Math.random() * 3 + 2,
            speed: Math.random() * 80 + 50,
            sway: Math.random() * Math.PI * 2,
            swaySpeed: Math.random() * 2 + 1
        };
    },
    update: function(dt) {
        if (!currentStageDef || currentStageDef.name !== 'Level 2') return;
        
        // If flakes empty, init
        if (this.flakes.length === 0) this.init();

        const w = width || window.innerWidth;
        const h = height || window.innerHeight;

        this.flakes.forEach(f => {
            f.y += f.speed * dt;
            f.sway += f.swaySpeed * dt;
            f.x += Math.sin(f.sway) * 20 * dt;
            
            if (player) {
                f.x -= player.vx * dt * 0.5; 
                f.y -= player.vy * dt * 0.5;
            }

            if (f.y > h) f.y = -10;
            if (f.y < -10) f.y = h;
            if (f.x > w) f.x = 0;
            if (f.x < 0) f.x = w;
        });
    },
    draw: function(ctx) {
        if (!currentStageDef || currentStageDef.name !== 'Level 2') return;
        
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.fillStyle = '#e0ffff'; // Light Cyan
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#000'; // Dark shadow for contrast
        ctx.beginPath();
        this.flakes.forEach(f => {
            ctx.moveTo(f.x + f.r, f.y); // Move to edge of circle to avoid line
            ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
        });
        ctx.fill();
        ctx.restore();
    }
};

function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;

    update(dt);
    draw();
    drawMinimap();

    requestAnimationFrame(gameLoop);
}

function update(dt) {
    if (!player) return;

    SnowSystem.update(dt);

    if (runResetTimer > 0) {
        runResetTimer -= dt;
        if (runResetTimer <= 0) {
            startRun();
            return;
        }
    }

    // Update Explosions (always)
    for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].update(dt);
        if (explosions[i].life <= 0) {
            explosions[i] = explosions[explosions.length - 1];
            explosions.pop();
        }
    }

    // Update Particles (always)
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        if (particles[i].life <= 0) {
            particles[i] = particles[particles.length - 1];
            particles.pop();
        }
    }

    if (gameMode !== 'play') {
        setWaterWarning(null);
        return;
    }

    const bossActive = !!(boss && !boss.dead);

    // Update Stage Objectives
    updateStageObjectives(dt);
    if (stageState && stageState.mosasaur && !player.dead) stageState.mosasaur.update(dt, player);

    // Update PowerUps (no new spawns during boss fights)
    if (!bossActive && powerUps.length < 20 && Math.random() < 0.015) spawnPowerUp();

    for (let i = powerUps.length - 1; i >= 0; i--) {
        powerUps[i].update(dt);
        if (player.dead) continue;

        const dx = player.x - powerUps[i].x;
        const dy = player.y - powerUps[i].y;
        if (Math.sqrt(dx*dx + dy*dy) < player.r + powerUps[i].r) {
            player.applyPowerUp(powerUps[i].type);
            AudioSys.playTone(600, 'sine', 0.1, 0.1, 'pickup'); 
            AudioSys.playTone(900, 'sine', 0.2, 0.1, 'pickup2');
            powerUps.splice(i, 1);
            updateHud();
        }
    }

    if (player.dead) {
        setWaterWarning(null);
        respawnTimer -= dt;
        if (runState.lives <= 0) return;

        if (respawnTimer <= 0) {
            player.x = runState.spawnX;
            player.y = runState.spawnY;

            player.health = player.maxHealth; 
            player.dead = false;
            player.invulnerableTimer = 3.0;
            player.vx = 0; 
            player.vy = 0;

            player.score = Math.floor(player.score * 0.9);
            runState.score = player.score;

            document.getElementById('game-over-ui').style.display = 'none';
            AudioSys.resumeMusic();
            entities.push(player);

            showNotification("Respawned!");
            respawnTimer = 3;
            updateHud();
        }
        return;
    } else {
        respawnTimer = 3; 
    }

    if (!bossActive && entities.length < 1200) {
        const desiredShapes = stageState?.def.spawn?.desiredShapes ?? 650;
        if (entities.filter(e => e instanceof Shape).length < desiredShapes) spawnShape();

        const maxEnemiesBase = 50;
        const maxEnemiesPerLevel = stageState?.def.spawn?.maxEnemiesPerLevel ?? 0.5;
        const maxEnemies = Math.max(10, Math.floor(maxEnemiesBase + (player.level * maxEnemiesPerLevel)));
        if (entities.filter(e => e instanceof Dino && !e.isPlayer && !e.isBoss).length < maxEnemies) spawnEnemy();
    }

    // Update Entities
    for (let i = entities.length - 1; i >= 0; i--) {
        entities[i].update(dt);
        if (entities[i].dead) {
            entities[i] = entities[entities.length - 1];
            entities.pop();
        }
    }

    // PERFORMANCE: Spatial Grid Collision
    spatialGrid.clear();
    for (let i = 0; i < entities.length; i++) {
        spatialGrid.insert(entities[i]);
    }

    for (let i = 0; i < entities.length; i++) {
        let e1 = entities[i];
        if (e1.dead) continue;
        
        if (e1 instanceof Shape) continue; 

        const potential = spatialGrid.query(e1);
        
        for (let j = 0; j < potential.length; j++) {
            let e2 = potential[j];
            if (e1 === e2 || e2.dead) continue;
            
            if (checkCollide(e1, e2)) handleCollision(e1, e2);
        }
    }

    entities = entities.filter(e => !e.dead);

    if (boss && boss.dead) {
        handleBossDefeated();
    }
    
    camera.x += (player.x - (width / 2 / camera.zoom) - camera.x) * 0.1;
    camera.y += (player.y - (height / 2 / camera.zoom) - camera.y) * 0.1;
    
    camera.zoom += (camera.targetZoom - camera.zoom) * 0.05;
    
    camera.x = clamp(camera.x, 0, CONFIG.mapWidth - (width/camera.zoom));
    camera.y = clamp(camera.y, 0, CONFIG.mapHeight - (height/camera.zoom));
}

function handleCollision(e1, e2) {
    const isBullet1 = e1 instanceof Bullet;
    const isBullet2 = e2 instanceof Bullet;

    if (isBullet1 || isBullet2) {
        if (isBullet1 && isBullet2) return;
        const bullet = isBullet1 ? e1 : e2;
        const target = isBullet1 ? e2 : e1;
        if (bullet.owner === target || (bullet.team === target.team && bullet.team !== 'neutral')) return;

        // Loot is immune to bullets (serves as cover)
        if (target instanceof Shape) {
            bullet.hitSomething();
            AudioSys.playTone(800, 'square', 0.05, 0.05); // Ricochet sound
            // Do not apply damage to Shape
            return;
        }

        target.takeDamage(bullet.damage, bullet.owner, bullet.type);
        bullet.hitSomething();
        
        const angle = Math.atan2(target.y - bullet.y, target.x - bullet.x);
        const knockback = bullet.type === 'flame' ? 0 : 100;
        target.vx += Math.cos(angle) * knockback * target.pushability;
        target.vy += Math.sin(angle) * knockback * target.pushability;
        return;
    }

    const sizeDiff = 1.15;
    
    if (e1.isPlayer || e2.isPlayer) {
        // Shapes cannot eat Dinos. Only Dinos can eat things.
        if (e1.r > e2.r * sizeDiff && !(e1 instanceof Shape)) {
            eatEntity(e1, e2);
            return;
        } else if (e2.r > e1.r * sizeDiff && !(e2 instanceof Shape)) {
            eatEntity(e2, e1);
            return;
        }
    }

    const angle = Math.atan2(e2.y - e1.y, e2.x - e1.x);
    const dist = Math.hypot(e2.x - e1.x, e2.y - e1.y);
    const overlap = (e1.r + e2.r) - dist;
    
    if (overlap > 0) {
        const force = overlap * 2;
        const rRatio = e2.r / (e1.r+e2.r);
        e1.x -= Math.cos(angle) * overlap * rRatio; e1.y -= Math.sin(angle) * overlap * rRatio;
        e2.x += Math.cos(angle) * overlap * (1-rRatio); e2.y += Math.sin(angle) * overlap * (1-rRatio);
        
        if (e1.team !== e2.team) {
            const s1 = e1 instanceof Shape;
            const s2 = e2 instanceof Shape;
            
            // Shapes (Loot) do not hurt Dinos
            if (s1 && e2 instanceof Dino) {
                if (e2.r > e1.r) e1.takeDamage(e2.bodyDamage * 0.2, e2, 'melee');
            } else if (s2 && e1 instanceof Dino) {
                if (e1.r > e2.r) e2.takeDamage(e1.bodyDamage * 0.2, e1, 'melee');
            } else {
                e1.takeDamage(e2.bodyDamage * 0.2, e2, 'melee');
                e2.takeDamage(e1.bodyDamage * 0.2, e1, 'melee');
            }
        }
    }
}

function draw() {
    ctx.save();
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, width, height);
    
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    const viewX = camera.x - 150;
    const viewY = camera.y - 150;
    const viewW = (width / camera.zoom) + 300;
    const viewH = (height / camera.zoom) + 300;

    drawTerrain(ctx, viewX, viewY, viewW, viewH);
    drawGrid();
    drawStageObjectives(ctx, viewX, viewY, viewW, viewH);

    explosions.forEach(ex => ex.draw(ctx));

    powerUps.forEach(p => {
        if (p.x + p.r > viewX && p.x - p.r < viewX + viewW && p.y + p.r > viewY && p.y - p.r < viewY + viewH) {
            p.draw(ctx);
        }
    });

    entities.sort((a,b) => {
        const getLayer = (e) => {
            if (e instanceof Shape) return 0;
            if (e instanceof Bullet && e.type === 'flame') return 1;
            return 2;
        };
        return getLayer(a) - getLayer(b);
    });

    entities.forEach(e => {
        if (e.x + e.r > viewX && e.x - e.r < viewX + viewW && e.y + e.r > viewY && e.y - e.r < viewY + viewH) {
            e.draw(ctx);
        }
    });

    particles.forEach(p => {
        if (p.x > viewX && p.x < viewX + viewW && p.y > viewY && p.y < viewY + viewH) {
            p.draw(ctx);
        }
    });

    drawDamageNumbers(ctx, viewX, viewY, viewW, viewH);

    // --- AIM ASSIST UI ---
    if (!player.dead) {
        let tx, ty;
        
        if (joystickRight.active) {
            // Visualize stick aim
            const reach = 400;
            tx = player.x + Math.cos(player.angle) * reach;
            ty = player.y + Math.sin(player.angle) * reach;
        } else {
            // Mouse aim
            tx = camera.x + (mouse.x / camera.zoom);
            ty = camera.y + (mouse.y / camera.zoom);
        }

        ctx.strokeStyle = 'rgba(255, 50, 50, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]); // Dashed line for "faint" feel
        
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        
        ctx.setLineDash([]);
        
        // Reticle
        ctx.fillStyle = 'rgba(255, 50, 50, 0.1)';
        ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
        ctx.beginPath();
        ctx.arc(tx, ty, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Crosshair center dot
        ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
        ctx.beginPath();
        ctx.arc(tx, ty, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
    
    SnowSystem.draw(ctx);
}

function drawGrid() {
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    const startX = Math.floor(camera.x / CONFIG.gridSize) * CONFIG.gridSize;
    const startY = Math.floor(camera.y / CONFIG.gridSize) * CONFIG.gridSize;
    const endX = startX + (width / camera.zoom) + CONFIG.gridSize;
    const endY = startY + (height / camera.zoom) + CONFIG.gridSize;

    for (let x = startX; x < endX; x += CONFIG.gridSize) {
        ctx.moveTo(x, camera.y); ctx.lineTo(x, endY);
    }
    for (let y = startY; y < endY; y += CONFIG.gridSize) {
        ctx.moveTo(camera.x, y); ctx.lineTo(endX, y);
    }
    ctx.stroke();
    
    if (bossArena && boss && !boss.dead) {
        ctx.fillStyle = 'rgba(80, 0, 80, 0.12)';
        ctx.beginPath();
        ctx.arc(bossArena.x, bossArena.y, bossArena.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 0, 120, 0.35)';
        ctx.lineWidth = 6;
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#444'; ctx.lineWidth = 20;
    ctx.strokeRect(0, 0, CONFIG.mapWidth, CONFIG.mapHeight);
}

function drawMinimap() {
    const miniCanvas = document.getElementById('minimap-canvas');
    const mCtx = miniCanvas.getContext('2d');
    const scale = miniCanvas.width / CONFIG.mapWidth;

    mCtx.clearRect(0,0,200,200);
    
    mCtx.fillStyle = 'rgba(30, 30, 30, 0.8)';
    mCtx.fillRect(0,0,200,200);

    // Boss arena hint
    if (bossArena && boss && !boss.dead) {
        mCtx.strokeStyle = 'rgba(255, 0, 100, 0.25)';
        mCtx.lineWidth = 2;
        mCtx.beginPath();
        mCtx.arc(bossArena.x * scale, bossArena.y * scale, bossArena.r * scale, 0, Math.PI * 2);
        mCtx.stroke();
    }

    // Objectives (fog-of-war reveal)
    if (stageState && player) {
        const jewelReveal = (stageState.def && stageState.def.minimapReveal) ? stageState.def.minimapReveal.jewel : 800;
        const gateReveal = (stageState.def && stageState.def.minimapReveal) ? stageState.def.minimapReveal.gate : 900;

        stageState.jewels.forEach(j => {
            const d = Math.hypot(player.x - j.x, player.y - j.y);
            if (d > jewelReveal) return;
            mCtx.fillStyle = j.jewelType.color;
            mCtx.beginPath();
            mCtx.arc(j.x * scale, j.y * scale, 3.2, 0, Math.PI * 2);
            mCtx.fill();
        });

        if (stageState.gate) {
            const g = stageState.gate;
            const d = Math.hypot(player.x - g.x, player.y - g.y);
            if (d <= gateReveal || g.unlocked) {
                mCtx.fillStyle = g.unlocked ? '#7bffb3' : '#aaaaaa';
                mCtx.beginPath();
                mCtx.rect(g.x * scale - 3, g.y * scale - 3, 6, 6);
                mCtx.fill();
            }
        }

        if (stageState.artifact) {
            const a = stageState.artifact;
            const d = Math.hypot(player.x - a.x, player.y - a.y);
            if (d <= gateReveal) {
                mCtx.fillStyle = '#ff66ff';
                mCtx.beginPath();
                mCtx.arc(a.x * scale, a.y * scale, 3.5, 0, Math.PI * 2);
                mCtx.fill();
            }
        }
    }

    entities.forEach(e => {
        if (e instanceof Shape && e.type !== 'alpha_fossil' && e.type !== 'amber') return; 
        
        let color = '#fff';
        let size = 2;
        
        if (e === player) { color = '#0ff'; size = 3; }
        else if (e.isBoss) { color = '#a0c'; size = 5; }
        else if (e.type === 'alpha_fossil') { color = '#768dfc'; size = 3; }
        else if (e.type === 'amber') { color = '#ff8c00'; size = 2.5; }
        else if (e instanceof Dino) { color = e.team === player.team ? 'blue' : 'red'; }

        mCtx.fillStyle = color;
        mCtx.beginPath();
        mCtx.arc(e.x * scale, e.y * scale, size, 0, Math.PI*2);
        mCtx.fill();
        
        if (e === player) {
            mCtx.strokeStyle = '#fff';
            mCtx.lineWidth = 1;
            mCtx.stroke();
        }
    });
}

function spawnDamageNumber(x, y, dmg, color='white', size=12) {
    if (dmg < 1) return;
    damageNumbers.push({x: x, y: y - 10, text: dmg, life: 1.0, vy: -20, color: color, size: size});
}

function drawDamageNumbers(ctx, vx, vy, vw, vh) {
    ctx.textAlign = 'center'; ctx.font = 'bold 12px Ubuntu';
    ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.fillStyle = 'white';
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
        let d = damageNumbers[i]; d.y += d.vy * 0.016; d.life -= 0.03;
        if (d.life <= 0) { damageNumbers.splice(i, 1); continue; }
        
        if (d.x > vx && d.x < vx + vw && d.y > vy && d.y < vy + vh) {
            ctx.globalAlpha = d.life;
            ctx.fillStyle = d.color;
            ctx.font = `bold ${d.size}px Ubuntu`;
            ctx.strokeText(d.text, d.x, d.y); ctx.fillText(d.text, d.x, d.y);
        }
    }
    ctx.globalAlpha = 1;
}

function setupUpgradeUI() {
    const container = document.getElementById('action-bar');
    container.innerHTML = '';
    
    // Pixel-perfect centering for 800x400 sheet (Ratio 2.0)
    const size = 48; 
    const ratio = 2.0; 
    
    // Scale height to match container (cover height)
    const bgH = size * 4; 
    const bgW = bgH * ratio;
    
    const cellW = bgW / 4; 
    const centerOffX = (cellW - size) / 2;

    STAT_TYPES.forEach((stat, index) => {
        const btn = document.createElement('div');
        btn.className = 'action-btn disabled';
        btn.id = `stat-btn-${index}`;
        btn.onclick = () => upgradeStat(index);
        btn.dataset.title = stat.name; 
        
        const grid = STAT_ICONS[index];
        
        // Shift to cell start, then shift back to center
        const offX = - (grid.c * cellW) - centerOffX;
        const offY = - (grid.r * size);
        
        btn.style.backgroundSize = `${bgW}px ${bgH}px`;
        btn.style.backgroundPosition = `${offX}px ${offY}px`;

        btn.innerHTML = `<div class="stat-lvl" id="stat-lvl-${index}">0</div><div class="stat-key-hint">${index+1}</div>`;
        container.appendChild(btn);
    });
}

function updateUpgradeUi() {
    STAT_TYPES.forEach((stat, index) => {
        const val = player.stats[index];
        const btn = document.getElementById(`stat-btn-${index}`);
        const lvl = document.getElementById(`stat-lvl-${index}`);
        
        if (lvl) lvl.innerText = val;
        
        if (btn) {
            if (player.points > 0) {
                btn.classList.remove('disabled');
                btn.classList.add('active');
            } else {
                btn.classList.add('disabled');
                btn.classList.remove('active');
            }
        }
    });
}

function checkWeaponUpgrades() {
    if (!player || player.dead) return;
    if (gameMode !== 'play') return;

    const menu = document.getElementById('class-upgrade-menu');
    menu.innerHTML = '';
    
    // Find the earliest milestone that hasn't been taken
    let targetMilestone = 0;
    for(let m = 15; m <= player.level; m += 15) {
        if (!player.upgradesTaken.includes(m)) {
            targetMilestone = m;
            break; 
        }
    }

    if (targetMilestone === 0) return;

    // Weapon upgrades only (species changes happen only after boss fights)
    const options = [];
    let pool = [...MUTATIONS];

    // Early milestones bias toward core weapon grafts.
    if (targetMilestone === 15) pool = pool.slice(0, 5);
    if (targetMilestone === 30) pool = pool.slice(0, 6);

    for (let i = 0; i < 3; i++) {
        if (pool.length === 0) break;
        const idx = Math.floor(Math.random() * pool.length);
        options.push(pool[idx]);
        pool.splice(idx, 1);
    }

    if (!options || options.length === 0) {
        // Safety: If no options found (e.g. invalid class path), skip milestone
        player.upgradesTaken.push(targetMilestone);
        return;
    }

    // Pixel-perfect sprite centering for 800x400 sheet (Ratio 2.0)
    const size = 64; 
    const ratio = 2.0;
    
    // Scale height to match container (cover height)
    const bgH = size * 4;
    const bgW = bgH * ratio;
    
    const cellW = bgW / 4;
    const centerOffX = (cellW - size) / 2;

    options.forEach(opt => {
        const card = document.createElement('div');
        card.className = 'class-card mutation';
        
        let title = opt.name;
        let desc = opt.desc;
        
        // Icon Mapping
        let iconRow = 3, iconCol = 1; // DNA
        
        const offX = - (iconCol * cellW) - centerOffX;
        const offY = - (iconRow * size);

        card.innerHTML = `<div class="class-card-icon" style="background-size: ${bgW}px ${bgH}px; background-position: ${offX}px ${offY}px"></div><div class="class-card-title">${title}</div><div class="class-card-desc">${desc}</div>`;
        
        card.onclick = () => {
            opt.action(player);
            showNotification(`Upgraded: ${opt.name}!`);
            
            if (!player.upgradesTaken.includes(targetMilestone)) {
                player.upgradesTaken.push(targetMilestone);
            }
            
            menu.innerHTML = '';
            
            // Check again in case multiple milestones were passed at once
            setTimeout(checkWeaponUpgrades, 100); 
        };
        menu.appendChild(card);
    });
}

function updateHud() {
    const stageNum = runState.stageIndex + 1;
    const stageName = currentStageDef?.name || `Level ${stageNum}`;
    const jewelText = stageState ? `${stageState.jewelsCollected}/${stageState.jewelTotal}` : `0/0`;

    document.getElementById('score-text').innerText = `Score: ${Math.floor(runState.score)}`;
    document.getElementById('class-text').innerText = `Lvl ${player.level} ${player.className}`;
    document.getElementById('run-text').innerText = `${stageName} (${stageNum}/${RUN_CONFIG.totalStages}) â€¢ Lives ${runState.lives}/${RUN_CONFIG.maxLives}`;
    document.getElementById('xp-bar-fill').style.width = `${Math.min(100, (player.xp / player.maxXp) * 100)}%`;

    // Crystal HUD
    const crystalHud = document.getElementById('crystal-hud');
    if (crystalHud && stageState) {
        crystalHud.innerHTML = '';
        for(let i=0; i<stageState.jewelTotal; i++) {
            const slot = document.createElement('div');
            const filled = i < stageState.jewelsCollected;
            slot.className = filled ? 'crystal-slot filled' : 'crystal-slot';
            
            const type = JEWEL_TYPES[i % JEWEL_TYPES.length];
            
            const icon = document.createElement('div');
            icon.className = 'crystal-icon';
            icon.style.backgroundColor = type.color;
            icon.style.color = type.color;
            
            slot.appendChild(icon);
            crystalHud.appendChild(slot);
        }
    }
}

function updateBossBar() {
    if (!boss) return;
    const fill = document.getElementById('boss-bar-fill');
    fill.style.width = `${(boss.health / boss.maxHealth) * 100}%`;
}

function upgradeStat(id) {
    if (player.points > 0) {
        player.points--; player.stats[id]++; player.recalcStats(); updateUpgradeUi();
    }
}

function showNotification(text) {
    const area = document.getElementById('notification-area');
    const note = document.createElement('div');
    note.className = 'notification'; note.innerText = text;
    area.appendChild(note); setTimeout(() => note.remove(), 3000);
}

function resetGame() {
    if (!confirm("Restart the run from Level 1?")) return;
    localStorage.removeItem('dino_io_save');
    hideOverlays();
    startRun();
}
</script>
</body>
</html>
